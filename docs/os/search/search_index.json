{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"%E4%BB%8B%E7%BB%8D/%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/","text":"","title":"\u5185\u6838\u7ed3\u6784\u4ecb\u7ecd"},{"location":"%E4%BB%8B%E7%BB%8D/%E6%BA%90%E7%A0%81%E6%B5%8F%E8%A7%88%E6%96%B9%E6%B3%95/","text":"1 \u63a8\u8350\u5de5\u5177 \u00b6 \u63a8\u8350\u4f7f\u7528 vim + ctags + taglist \u6d4f\u89c8\u6e90\u7801 2 ctags\u5b89\u88c5 \u00b6 Ubuntu\u4e0b\u901a\u8fc7apt-get \u5b89\u88c5ctags sudo apt-get install ctags Mac\u4e0b\u901a\u8fc7brew\u5b89\u88c5ctags brew install ctags 3 taglist\u5b89\u88c5 \u00b6 \u9996\u5148\u9700\u8981\u5728\u5b98\u7f51\u4e0a\u4e0b\u8f7dtaglist\u811a\u672c\uff0c\u547d\u540d\u683c\u5f0f\u4e3ataglist_xx.zip\uff0c\u4e0b\u8f7d\u5730\u5740\u5982\u4e0b\uff1a http://www.vim.org/scripts/script.php?script_id=273 \u89e3\u538b\u540e\u901a\u8fc7\u5982\u4e0b\u547d\u4ee4\u5c06\u811a\u672c\u653e\u5165vim\u914d\u7f6e\u4e2d\uff1a $cp ./doc/taglist.txt /usr/share/vim/vimxx/doc $cp ./plugin/taglist.vim /usr/share/vim/vimxx/plugin \u542f\u52a8vim\uff0c\u901a\u8fc7 :helptags . \u6765\u914d\u7f6e\u5e2e\u52a9\u6587\u6863\uff1b \u91cd\u542fvim\uff0c\u901a\u8fc7 :TlistToggle \u6765\u6253\u5f00\u548c\u5173\u95edtaglist\u7a97\u53e3\uff1b \u901a\u8fc7 :help taglist \u6765\u83b7\u53d6\u66f4\u591a\u5e2e\u52a9\u4fe1\u606f\u3002 \u5982\u679c\u8981\u9ed8\u8ba4\u6253\u5f00taglist\uff0c\u5728.vimrc\u6587\u4ef6\u4e2d\u6dfb\u52a0\u4ee5\u4e0b\u4fe1\u606f\uff1a let Tlist_Auto_Open=1 set tags=tags; set autochdir 4 \u5173\u8054taglist\u548cctags \u00b6 \u9996\u5148\u901a\u8fc7 which ctags \u67e5\u770bctags\u7a0b\u5e8f\u7684\u5b89\u88c5\u4f4d\u7f6e\u3002 \u7136\u540e\u9700\u8981\u4fee\u6539/usr/share/vim/vimxx/plugin/taglist.vim\u6587\u4ef6\uff0c\u914d\u7f6eTlist_Ctags_Cmd\u53c2\u6570\u7684\u8def\u5f84\u3002\u4f8b\u5982\uff0c\u6211\u7535\u8111\u4e0actags\u547d\u4ee4\u7684\u4f4d\u7f6e\u662f /usr/local/bin/ctags ,\u5219\u9700\u8981\u6dfb\u52a0\u4ee5\u4e0b\u547d\u4ee4\uff1a Tlist_Ctags_Cmd=\"/usr/local/bin/ctags\" 5 \u4f7f\u7528\u65b9\u6cd5 \u00b6 \u5728\u6e90\u7801\u76ee\u5f55\u4e2d\uff08\u53ef\u4ee5\u53ea\u9009\u62e9 ../x86 \u76ee\u5f55\uff09\uff0c\u901a\u8fc7 ctags -R * \u751f\u6210tags\uff0c\u7136\u540e\u4f7f\u7528vim\u67e5\u770b\u4ee3\u7801\u5373\u53ef\u3002","title":"\u6e90\u7801\u6d4f\u89c8\u65b9\u6cd5"},{"location":"%E4%BB%8B%E7%BB%8D/%E6%BA%90%E7%A0%81%E6%B5%8F%E8%A7%88%E6%96%B9%E6%B3%95/#1","text":"\u63a8\u8350\u4f7f\u7528 vim + ctags + taglist \u6d4f\u89c8\u6e90\u7801","title":"1 \u63a8\u8350\u5de5\u5177"},{"location":"%E4%BB%8B%E7%BB%8D/%E6%BA%90%E7%A0%81%E6%B5%8F%E8%A7%88%E6%96%B9%E6%B3%95/#2-ctags","text":"Ubuntu\u4e0b\u901a\u8fc7apt-get \u5b89\u88c5ctags sudo apt-get install ctags Mac\u4e0b\u901a\u8fc7brew\u5b89\u88c5ctags brew install ctags","title":"2 ctags\u5b89\u88c5"},{"location":"%E4%BB%8B%E7%BB%8D/%E6%BA%90%E7%A0%81%E6%B5%8F%E8%A7%88%E6%96%B9%E6%B3%95/#3-taglist","text":"\u9996\u5148\u9700\u8981\u5728\u5b98\u7f51\u4e0a\u4e0b\u8f7dtaglist\u811a\u672c\uff0c\u547d\u540d\u683c\u5f0f\u4e3ataglist_xx.zip\uff0c\u4e0b\u8f7d\u5730\u5740\u5982\u4e0b\uff1a http://www.vim.org/scripts/script.php?script_id=273 \u89e3\u538b\u540e\u901a\u8fc7\u5982\u4e0b\u547d\u4ee4\u5c06\u811a\u672c\u653e\u5165vim\u914d\u7f6e\u4e2d\uff1a $cp ./doc/taglist.txt /usr/share/vim/vimxx/doc $cp ./plugin/taglist.vim /usr/share/vim/vimxx/plugin \u542f\u52a8vim\uff0c\u901a\u8fc7 :helptags . \u6765\u914d\u7f6e\u5e2e\u52a9\u6587\u6863\uff1b \u91cd\u542fvim\uff0c\u901a\u8fc7 :TlistToggle \u6765\u6253\u5f00\u548c\u5173\u95edtaglist\u7a97\u53e3\uff1b \u901a\u8fc7 :help taglist \u6765\u83b7\u53d6\u66f4\u591a\u5e2e\u52a9\u4fe1\u606f\u3002 \u5982\u679c\u8981\u9ed8\u8ba4\u6253\u5f00taglist\uff0c\u5728.vimrc\u6587\u4ef6\u4e2d\u6dfb\u52a0\u4ee5\u4e0b\u4fe1\u606f\uff1a let Tlist_Auto_Open=1 set tags=tags; set autochdir","title":"3 taglist\u5b89\u88c5"},{"location":"%E4%BB%8B%E7%BB%8D/%E6%BA%90%E7%A0%81%E6%B5%8F%E8%A7%88%E6%96%B9%E6%B3%95/#4-taglistctags","text":"\u9996\u5148\u901a\u8fc7 which ctags \u67e5\u770bctags\u7a0b\u5e8f\u7684\u5b89\u88c5\u4f4d\u7f6e\u3002 \u7136\u540e\u9700\u8981\u4fee\u6539/usr/share/vim/vimxx/plugin/taglist.vim\u6587\u4ef6\uff0c\u914d\u7f6eTlist_Ctags_Cmd\u53c2\u6570\u7684\u8def\u5f84\u3002\u4f8b\u5982\uff0c\u6211\u7535\u8111\u4e0actags\u547d\u4ee4\u7684\u4f4d\u7f6e\u662f /usr/local/bin/ctags ,\u5219\u9700\u8981\u6dfb\u52a0\u4ee5\u4e0b\u547d\u4ee4\uff1a Tlist_Ctags_Cmd=\"/usr/local/bin/ctags\"","title":"4 \u5173\u8054taglist\u548cctags"},{"location":"%E4%BB%8B%E7%BB%8D/%E6%BA%90%E7%A0%81%E6%B5%8F%E8%A7%88%E6%96%B9%E6%B3%95/#5","text":"\u5728\u6e90\u7801\u76ee\u5f55\u4e2d\uff08\u53ef\u4ee5\u53ea\u9009\u62e9 ../x86 \u76ee\u5f55\uff09\uff0c\u901a\u8fc7 ctags -R * \u751f\u6210tags\uff0c\u7136\u540e\u4f7f\u7528vim\u67e5\u770b\u4ee3\u7801\u5373\u53ef\u3002","title":"5 \u4f7f\u7528\u65b9\u6cd5"},{"location":"%E4%BB%8B%E7%BB%8D/%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/","text":"","title":"\u76f8\u5173\u5de5\u5177\u4ecb\u7ecd"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E5%86%85%E6%A0%B8/","text":"qemu\u53c2\u6570\u8bf4\u660e -S freeze CPU at startup (use 'c' to start execution) -s shorthand for -gdb tcp::1234","title":"\u4f7f\u7528GDB\u8c03\u8bd5\u5185\u6838"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/","text":"1 \u5b89\u88c5qemu \u00b6 sudo apt install qemu sudo apt install qemu-system-x86_64 2 \u5236\u4f5c\u78c1\u76d8\u955c\u50cf \u00b6 2.1 \u521b\u5efa\u78c1\u76d8 \u00b6 \u4f7f\u7528 qemu-img \u521b\u5efa\u4e00\u4e2a512M\u7684\u78c1\u76d8\u955c\u50cf\u6587\u4ef6 qemu-img create -f raw disk.raw 512M \u4f7f\u7528 mkfs \u5bf9\u78c1\u76d8\u955c\u50cf\u8fdb\u884c\u683c\u5f0f\u5316 mkfs -t ext4 ./disk.raw 2.2 \u6302\u8f7d\u78c1\u76d8\u955c\u50cf \u00b6 \u4f7f\u7528 mount \u4ee5loop\u65b9\u5f0f\u5c06\u78c1\u76d8\u6587\u4ef6\u6302\u8f7d\u5230\u4e00\u4e2a\u76ee\u5f55\u4e0a sudo mount -o loop ./disk.raw ./img 2.3 \u5b89\u88c5\u5185\u6838\u6a21\u5757 \u00b6 \u5728linux\u6e90\u7801\u76ee\u5f55\u4e0b\u8fd0\u884c sudo make modules_install \\ #\u5b89\u88c5\u5185\u6838\u6a21\u5757 INSTALL_MOD_PATH = ./img #\u6307\u5b9a\u5b89\u88c5\u8def\u5f84 2.4 \u914d\u7f6einit\u7a0b\u5e8f \u00b6 \u53c2\u8003busybox \u4ee3\u7801\u6587\u6863 \u53ef\u77e5\uff0cinit\u542f\u52a8\u540e\u4f1a\u626b\u63cf /etc/inittab \u914d\u7f6e\u6587\u4ef6\uff0c\u8fd9\u4e2a\u914d\u7f6e\u6587\u4ef6\u51b3\u5b9a\u4e86init\u7a0b\u5e8f\u7684\u884c\u4e3a\u3002\u800cbusybox init\u5728\u6ca1\u6709 /etc/inittab \u6587\u4ef6\u7684\u60c5\u51b5\u4e0b\u4e5f\u80fd\u5de5\u4f5c\uff0c\u56e0\u4e3a\u5b83\u6709\u9ed8\u8ba4\u884c\u4e3a\u3002\u5b83\u7684\u9ed8\u8ba4\u884c\u4e3a\u76f8\u5f53\u4e8e\u5982\u4e0b\u914d\u7f6e\uff1a ::sysinit:/etc/init.d/rcS ::askfirst:/bin/sh ::ctrlaltdel:/sbin/reboot ::shutdown:/sbin/swapoff -a ::shutdown:/bin/umount -a -r ::restart:/sbin/init tty2::askfirst:/bin/sh tty3::askfirst:/bin/sh tty4::askfirst:/bin/sh \u53c2\u8003\u6587\u6863\uff0c\u8fdb\u884c\u5982\u4e0b\u64cd\u4f5c cd ./img sudo mkdir ./etc cd ./etc sudo vim inittab \u8f93\u5165\u914d\u7f6e\u5982\u4e0b\uff1a ::sysinit:/etc/init.d/rcS console::askfirst:-/bin/sh ::ctrlaltdel:/sbin/reboot ::shutdown:/sbin/swapoff -a ::shutdown:/bin/umount -a -r ::restart:/sbin/init \u521b\u5efa\u53ef\u6267\u884c\u6587\u4ef6 /etc/init.d/rcS cd ./img sudo mkdir ./etc/init.d cd ./etc/init.d sudo vim rcS sudo chmod 777 rcS \u7a0b\u5e8f\u5185\u5bb9\u5982\u4e0b\uff08\u7a7a\u7a0b\u5e8f\uff09\uff1a #!/bin/sh 3 \u5236\u4f5cinit\u7a0b\u5e8f \u00b6 3.1 \u7f16\u8bd1busybox\u7a0b\u5e8f \u00b6 \u4e0b\u8f7dbusybox\u6e90\u7801\uff0c\u8fdb\u5165\u6e90\u7801\u76ee\u5f55\uff0c\u542f\u7528\u9ed8\u8ba4\u914d\u7f6e make defconfig \u4f7f\u7528\u83dc\u5355\u7a0b\u5e8f\u5b9a\u5236\u914d\u7f6e make menuconfig \u56e0\u4e3a\u78c1\u76d8\u955c\u50cf\u4e2d\u6ca1\u6709\u7a0b\u5e8f\u5e93\uff0c\u9700\u8981\u5c06busybox\u7f16\u8bd1\u6210\u4e00\u4e2a\u72ec\u7acb\u3001\u65e0\u4f9d\u8d56\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u7a97\u53e3\u914d\u7f6e\u8def\u5f84\u5982\u4e0b\uff1a Settings ---> --- Build Options [ * ] Build static binary ( no shared libs ) \u914d\u7f6e\u5b8c\u540e\u6267\u884c\u7f16\u8bd1 make 3.2 \u5b89\u88c5busybox\u5230\u78c1\u76d8\u955c\u50cf \u00b6 make CONFIG_PREFIX = ./img \\ #\u78c1\u76d8\u6587\u4ef6\u7684\u6302\u8f7d\u8def\u5f84 install 4 qemu\u542f\u52a8\u5185\u6838 \u00b6 qemu-system-x86_64 \\ -m 512M \\ #\u6307\u5b9a\u5185\u5b58\u5927\u5c0f -smp 2 \\ #\u6307\u5b9a\u865a\u62df\u7684CPU\u6570\u91cf -kernel ./bzImage \\ #\u6307\u5b9a\u5185\u6838\u6587\u4ef6\u8def\u5f84 -drive format = raw,file = ./disk.raw \\ #\u6307\u5b9a\u6587\u4ef6\u4e3a\u78c1\u76d8 -append \"init=/linuxrc root=/dev/sda\" #\u5185\u6838\u542f\u52a8\u53c2\u6570 5 \u6302\u8f7d\u6587\u4ef6\u7cfb\u7edf \u00b6 \u521b\u5efa/dev\uff0c/proc\uff0c/sys\u76ee\u5f55 cd ./img sudo mkdir ./dev sudo mkdir ./proc sudo mkdir ./sys \u5176\u4e2d\uff0c/dev\u76ee\u5f55\u4f1a\u5728\u91cd\u542f\u7cfb\u7edf\u65f6\u81ea\u52a8\u6302\u8f7d\uff0c/proc\uff0c/sys\u9700\u8981\u624b\u52a8\u6302\u8f7d\uff0c\u901a\u8fc7\u4fee\u6539 ./etc/init.d/rcS \u6587\u4ef6\u4f7f\u8ba1\u7b97\u673a\u81ea\u52a8\u6302\u8f7d\uff0c\u4fee\u6539 ./etc/init.d/rcS \u5185\u5bb9\u5982\u4e0b\uff1a #!/bin/sh mount -t proc proc /proc mount -t sysfs sysfs /sys","title":"\u4f7f\u7528QEMU\u8fd0\u884c\u5185\u6838"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#1-qemu","text":"sudo apt install qemu sudo apt install qemu-system-x86_64","title":"1 \u5b89\u88c5qemu"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#2","text":"","title":"2 \u5236\u4f5c\u78c1\u76d8\u955c\u50cf"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#21","text":"\u4f7f\u7528 qemu-img \u521b\u5efa\u4e00\u4e2a512M\u7684\u78c1\u76d8\u955c\u50cf\u6587\u4ef6 qemu-img create -f raw disk.raw 512M \u4f7f\u7528 mkfs \u5bf9\u78c1\u76d8\u955c\u50cf\u8fdb\u884c\u683c\u5f0f\u5316 mkfs -t ext4 ./disk.raw","title":"2.1 \u521b\u5efa\u78c1\u76d8"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#22","text":"\u4f7f\u7528 mount \u4ee5loop\u65b9\u5f0f\u5c06\u78c1\u76d8\u6587\u4ef6\u6302\u8f7d\u5230\u4e00\u4e2a\u76ee\u5f55\u4e0a sudo mount -o loop ./disk.raw ./img","title":"2.2 \u6302\u8f7d\u78c1\u76d8\u955c\u50cf"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#23","text":"\u5728linux\u6e90\u7801\u76ee\u5f55\u4e0b\u8fd0\u884c sudo make modules_install \\ #\u5b89\u88c5\u5185\u6838\u6a21\u5757 INSTALL_MOD_PATH = ./img #\u6307\u5b9a\u5b89\u88c5\u8def\u5f84","title":"2.3 \u5b89\u88c5\u5185\u6838\u6a21\u5757"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#24-init","text":"\u53c2\u8003busybox \u4ee3\u7801\u6587\u6863 \u53ef\u77e5\uff0cinit\u542f\u52a8\u540e\u4f1a\u626b\u63cf /etc/inittab \u914d\u7f6e\u6587\u4ef6\uff0c\u8fd9\u4e2a\u914d\u7f6e\u6587\u4ef6\u51b3\u5b9a\u4e86init\u7a0b\u5e8f\u7684\u884c\u4e3a\u3002\u800cbusybox init\u5728\u6ca1\u6709 /etc/inittab \u6587\u4ef6\u7684\u60c5\u51b5\u4e0b\u4e5f\u80fd\u5de5\u4f5c\uff0c\u56e0\u4e3a\u5b83\u6709\u9ed8\u8ba4\u884c\u4e3a\u3002\u5b83\u7684\u9ed8\u8ba4\u884c\u4e3a\u76f8\u5f53\u4e8e\u5982\u4e0b\u914d\u7f6e\uff1a ::sysinit:/etc/init.d/rcS ::askfirst:/bin/sh ::ctrlaltdel:/sbin/reboot ::shutdown:/sbin/swapoff -a ::shutdown:/bin/umount -a -r ::restart:/sbin/init tty2::askfirst:/bin/sh tty3::askfirst:/bin/sh tty4::askfirst:/bin/sh \u53c2\u8003\u6587\u6863\uff0c\u8fdb\u884c\u5982\u4e0b\u64cd\u4f5c cd ./img sudo mkdir ./etc cd ./etc sudo vim inittab \u8f93\u5165\u914d\u7f6e\u5982\u4e0b\uff1a ::sysinit:/etc/init.d/rcS console::askfirst:-/bin/sh ::ctrlaltdel:/sbin/reboot ::shutdown:/sbin/swapoff -a ::shutdown:/bin/umount -a -r ::restart:/sbin/init \u521b\u5efa\u53ef\u6267\u884c\u6587\u4ef6 /etc/init.d/rcS cd ./img sudo mkdir ./etc/init.d cd ./etc/init.d sudo vim rcS sudo chmod 777 rcS \u7a0b\u5e8f\u5185\u5bb9\u5982\u4e0b\uff08\u7a7a\u7a0b\u5e8f\uff09\uff1a #!/bin/sh","title":"2.4 \u914d\u7f6einit\u7a0b\u5e8f"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#3-init","text":"","title":"3 \u5236\u4f5cinit\u7a0b\u5e8f"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#31-busybox","text":"\u4e0b\u8f7dbusybox\u6e90\u7801\uff0c\u8fdb\u5165\u6e90\u7801\u76ee\u5f55\uff0c\u542f\u7528\u9ed8\u8ba4\u914d\u7f6e make defconfig \u4f7f\u7528\u83dc\u5355\u7a0b\u5e8f\u5b9a\u5236\u914d\u7f6e make menuconfig \u56e0\u4e3a\u78c1\u76d8\u955c\u50cf\u4e2d\u6ca1\u6709\u7a0b\u5e8f\u5e93\uff0c\u9700\u8981\u5c06busybox\u7f16\u8bd1\u6210\u4e00\u4e2a\u72ec\u7acb\u3001\u65e0\u4f9d\u8d56\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u7a97\u53e3\u914d\u7f6e\u8def\u5f84\u5982\u4e0b\uff1a Settings ---> --- Build Options [ * ] Build static binary ( no shared libs ) \u914d\u7f6e\u5b8c\u540e\u6267\u884c\u7f16\u8bd1 make","title":"3.1 \u7f16\u8bd1busybox\u7a0b\u5e8f"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#32-busybox","text":"make CONFIG_PREFIX = ./img \\ #\u78c1\u76d8\u6587\u4ef6\u7684\u6302\u8f7d\u8def\u5f84 install","title":"3.2 \u5b89\u88c5busybox\u5230\u78c1\u76d8\u955c\u50cf"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#4-qemu","text":"qemu-system-x86_64 \\ -m 512M \\ #\u6307\u5b9a\u5185\u5b58\u5927\u5c0f -smp 2 \\ #\u6307\u5b9a\u865a\u62df\u7684CPU\u6570\u91cf -kernel ./bzImage \\ #\u6307\u5b9a\u5185\u6838\u6587\u4ef6\u8def\u5f84 -drive format = raw,file = ./disk.raw \\ #\u6307\u5b9a\u6587\u4ef6\u4e3a\u78c1\u76d8 -append \"init=/linuxrc root=/dev/sda\" #\u5185\u6838\u542f\u52a8\u53c2\u6570","title":"4 qemu\u542f\u52a8\u5185\u6838"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8QEMU%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/#5","text":"\u521b\u5efa/dev\uff0c/proc\uff0c/sys\u76ee\u5f55 cd ./img sudo mkdir ./dev sudo mkdir ./proc sudo mkdir ./sys \u5176\u4e2d\uff0c/dev\u76ee\u5f55\u4f1a\u5728\u91cd\u542f\u7cfb\u7edf\u65f6\u81ea\u52a8\u6302\u8f7d\uff0c/proc\uff0c/sys\u9700\u8981\u624b\u52a8\u6302\u8f7d\uff0c\u901a\u8fc7\u4fee\u6539 ./etc/init.d/rcS \u6587\u4ef6\u4f7f\u8ba1\u7b97\u673a\u81ea\u52a8\u6302\u8f7d\uff0c\u4fee\u6539 ./etc/init.d/rcS \u5185\u5bb9\u5982\u4e0b\uff1a #!/bin/sh mount -t proc proc /proc mount -t sysfs sysfs /sys","title":"5 \u6302\u8f7d\u6587\u4ef6\u7cfb\u7edf"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E8%BF%90%E8%A1%8C%E5%86%85%E6%A0%B8/","text":"\u53c2\u8003\u7f51\u7ad9\uff1a https://blog.csdn.net/zxy131072/article/details/83545436 https://codechina.csdn.net/?utm_source=csdn_toolbar","title":"\u4f7f\u7528\u6811\u8393\u6d3e\u8fd0\u884c\u5185\u6838"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/","text":"1 \u83b7\u53d6\u5185\u6838\u6e90\u7801 \u00b6 \u5b98\u65b9\u7f51\u7ad9\u4e0b\u8f7d\u901f\u5ea6\u592a\u6162\uff0c\u4f7f\u7528\u5982\u4e0b\u5730\u5740\u4e0b\u8f7d \u7b2c2\u4f4d\u662f\u5076\u6570\u8868\u793a\u5f53\u524d\u7248\u672c\u662f\u7a33\u5b9a\u7248\uff1b \u7b2c2\u4f4d\u662f\u5947\u6570\u8868\u793a\u5f53\u524d\u7248\u672c\u662f\u5f00\u53d1\u7248\uff0c\u662f\u5185\u6838\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u7684\u4e00\u4e2a\u5feb\u7167\uff1b \u4f8b\u5982\uff1a5.8.xx\u662f\u7a33\u5b9a\u7248\uff0c5.9.xx\u662f\u5f00\u53d1\u7248\uff1b \u5efa\u8bae\u4f7f\u7528\u7a33\u5b9a\u7248\u8fdb\u884c\u5b9e\u9a8c\u3002 http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/ 2 \u914d\u7f6egcc\u7248\u672c \u00b6 \u5b89\u88c5\u9700\u8981\u7684\u7248\u672c sudo apt install gcc-7 gcc-7-multilib g++-7 g++-7-multilib sudo apt install gcc-9 gcc-9-multilib g++-9 g++-9-multilib \u8bbe\u7f6e\u4f18\u5148\u7ea7 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 60 --slave /usr/bin/g++ g++ /usr/bin/g++-7 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 \u5207\u6362gcc\u7248\u672c sudo update-alternatives --config gcc 3 \u7f16\u8bd1\u5185\u6838\u6e90\u7801 \u00b6 \u6839\u636e\u73af\u5883\u521b\u5efa\u9ed8\u8ba4\u914d\u7f6e make defconfig \u7f16\u8bd1\u7a0b\u5e8f make #\u53ef\u4ee5\u4f7f\u7528make > /dev/null\u53bb\u6389\u8fd4\u56de\u4fe1\u606f \u7f16\u8bd1\u5185\u6838\u955c\u50cf make bzImage \u7f16\u8bd1\u5185\u6838\u6a21\u5757 make modules","title":"\u7f16\u8bd1\u5185\u6838"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/#1","text":"\u5b98\u65b9\u7f51\u7ad9\u4e0b\u8f7d\u901f\u5ea6\u592a\u6162\uff0c\u4f7f\u7528\u5982\u4e0b\u5730\u5740\u4e0b\u8f7d \u7b2c2\u4f4d\u662f\u5076\u6570\u8868\u793a\u5f53\u524d\u7248\u672c\u662f\u7a33\u5b9a\u7248\uff1b \u7b2c2\u4f4d\u662f\u5947\u6570\u8868\u793a\u5f53\u524d\u7248\u672c\u662f\u5f00\u53d1\u7248\uff0c\u662f\u5185\u6838\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u7684\u4e00\u4e2a\u5feb\u7167\uff1b \u4f8b\u5982\uff1a5.8.xx\u662f\u7a33\u5b9a\u7248\uff0c5.9.xx\u662f\u5f00\u53d1\u7248\uff1b \u5efa\u8bae\u4f7f\u7528\u7a33\u5b9a\u7248\u8fdb\u884c\u5b9e\u9a8c\u3002 http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/","title":"1 \u83b7\u53d6\u5185\u6838\u6e90\u7801"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/#2-gcc","text":"\u5b89\u88c5\u9700\u8981\u7684\u7248\u672c sudo apt install gcc-7 gcc-7-multilib g++-7 g++-7-multilib sudo apt install gcc-9 gcc-9-multilib g++-9 g++-9-multilib \u8bbe\u7f6e\u4f18\u5148\u7ea7 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 60 --slave /usr/bin/g++ g++ /usr/bin/g++-7 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 --slave /usr/bin/g++ g++ /usr/bin/g++-9 \u5207\u6362gcc\u7248\u672c sudo update-alternatives --config gcc","title":"2 \u914d\u7f6egcc\u7248\u672c"},{"location":"%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/#3","text":"\u6839\u636e\u73af\u5883\u521b\u5efa\u9ed8\u8ba4\u914d\u7f6e make defconfig \u7f16\u8bd1\u7a0b\u5e8f make #\u53ef\u4ee5\u4f7f\u7528make > /dev/null\u53bb\u6389\u8fd4\u56de\u4fe1\u606f \u7f16\u8bd1\u5185\u6838\u955c\u50cf make bzImage \u7f16\u8bd1\u5185\u6838\u6a21\u5757 make modules","title":"3 \u7f16\u8bd1\u5185\u6838\u6e90\u7801"},{"location":"%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/","text":"\u4e00\u822c\u6765\u8bf4\uff0c\u8fdb\u7a0b\u7684\u4ea7\u751f\u5206\u4e3a \u5728\u65b0\u5730\u5740\u7a7a\u95f4\u521b\u5efa\u8fdb \u7a0b \uff0c \u8bfb\u5165\u53ef\u6267\u884c\u6587\u4ef6 \uff0c \u5f00\u59cb\u6267\u884c \u3002\u5728Unix\u4e2d\uff0c\u4e0a\u8ff0\u6b65\u9aa4\u5206\u89e3\u5230\u4e86\u4e24\u4e2a\u5355\u72ec\u7684\u51fd\u6570fork\u548cexec\u3002 fork\u51fd\u6570\u901a\u8fc7 \u62f7\u8d1d\u5f53\u524d\u8fdb\u7a0b\u521b\u5efa\u5b50\u8fdb\u7a0b \uff0c\u5b50\u8fdb\u7a0b\u548c\u7236\u8fdb\u7a0b\u4e4b\u95f4\u7684\u533a\u522b\u4ec5\u4ec5\u5728\u4e8e PID \u3001 PPID \u548c \u67d0\u4e9b\u8d44\u6e90\u548c\u7edf\u8ba1\u91cf \uff08\u5982\u6302\u8d77\u7684\u4fe1\u53f7\uff09\uff1b exec\u51fd\u6570\u8d1f\u8d23 \u8bfb\u53d6\u53ef\u6267\u884c\u6587\u4ef6 \u5e76\u5c06\u5176 \u8f7d\u5165\u5730\u5740\u7a7a\u95f4\u5f00\u59cb\u8fd0\u884c \uff1b \u4f20\u7edffork\u56de\u76f4\u63a5\u628a\u6240\u6709\u7684\u8d44\u6e90\u590d\u5236\u7ed9\u65b0\u7684\u8fdb\u7a0b\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u65b0\u8fdb\u7a0b\u6253\u7b97\u6267\u884c\u4e00\u4e2a\u65b0\u7684\u6620\u50cf\uff0c\u90a3\u4e48\u6240\u6709\u7684\u62f7\u8d1d\u90fd\u5c06\u524d\u529f\u5c3d\u5f03\u3002Linux\u7684fork\u4f7f\u7528\u5199\u65f6\u62f7\u8d1d\u9875\u5b9e\u73b0\u3002\u5373\u8d44\u6e90\u7684\u590d\u5236\u53ea\u6709\u5728\u9700\u8981\u5199\u5165\u7684\u65f6\u5019\u624d\u8fdb\u884c\uff0c\u5199\u5165\u4e4b\u524d\u90fd\u662f\u4ee5\u53ea\u8bfb\u7684\u65b9\u5f0f\u8fdb\u884c\u5171\u4eab\u3002\u5728\u9875\u6839\u672c\u4e0d\u4f1a\u88ab\u5199\u5165\u7684\u60c5\u51b5\u4e0b\uff08\u4f8b\u5982\u5728\u8c03\u7528fork( )\u540e\u7acb\u5373\u8c03\u7528exec( )\uff09\u5c31\u65e0\u9700\u590d\u5236\u4e86\u3002 Linux\u901a\u8fc7clone()\u7cfb\u7edf\u8c03\u7528\u5b9e\u73b0fork()\u3002\u8be5\u8c03\u7528\u901a\u8fc7\u4e00\u4e9b\u5217\u7684\u53c2\u6570\u6807\u5fd7\u6765\u6307\u660e\u7236\u3001\u5b50\u8fdb\u7a0b\u9700\u8981\u5171\u4eab\u7684\u8d44\u6e90\u3002fork()\u3001vfork()\u548c__clone()\u90fd\u6839\u636e\u5404\u81ea\u9700\u8981\u7684\u6807\u5fd7\u53c2\u6570\u6765\u8c03\u7528clone()\uff0c\u7136\u540e\u7531clone\u6765\u8c03\u7528do_fork() [./kernel/fork.c] \u3002 ps:\u8bba\u662fif(likely(value))\u8fd8\u662fif(unlikely(value))\uff0c\u4ece\u4ee3\u7801\u9605\u8bfb\u7684\u89d2\u5ea6\u4e0eif(value)\u662f\u5b8c\u5168\u4e00\u6837\u7684\uff0c\u533a\u522b\u70b9\u5728\u4e8e\u7f16\u8bd1\u5668\u6839\u636e\u4e09\u79cd\u60c5\u51b5\u6240\u4f5c\u51fa\u7684\u4f18\u5316\u63aa\u65bd\u4e0d\u540c\uff1b \u200b likely\uff0c\u662f\u901a\u77e5\u7f16\u8bd1\u5668if (true)\u88ab\u6267\u884c\u7684\u6982\u7387\u6bd4\u8f83\u9ad8\uff1b \u200b unlikely\uff0c\u662f\u901a\u77e5\u7f16\u8bd1\u5668if(false)\u88ab\u6267\u884c\u7684\u6982\u7387\u6bd4\u8f83\u9ad8\uff1b /* * Ok, this is the main fork-routine. * * It copies the process, and if successful kick-starts * it and waits for it to finish using the VM if required. */ long do_fork ( unsigned long clone_flags , unsigned long stack_start , struct pt_regs * regs , unsigned long stack_size , int __user * parent_tidptr , int __user * child_tidptr ) { struct task_struct * p ; int trace = 0 ; long nr ; /* * Do some preliminary argument and permissions checking before we * actually start allocating stuff */ if ( clone_flags & CLONE_NEWUSER ) { if ( clone_flags & CLONE_THREAD ) return - EINVAL ; /* hopefully this check will go away when userns support is * complete */ if ( ! capable ( CAP_SYS_ADMIN ) || ! capable ( CAP_SETUID ) || ! capable ( CAP_SETGID )) return - EPERM ; } /* * We hope to recycle these flags after 2.6.26 */ if ( unlikely ( clone_flags & CLONE_STOPPED )) { static int __read_mostly count = 100 ; if ( count > 0 && printk_ratelimit ()) { char comm [ TASK_COMM_LEN ]; count -- ; printk ( KERN_INFO \"fork(): process `%s' used deprecated \" \"clone flags 0x%lx \\n \" , get_task_comm ( comm , current ), clone_flags & CLONE_STOPPED ); } } /* * When called from kernel_thread, don't do user tracing stuff. */ if ( likely ( user_mode ( regs ))) trace = tracehook_prepare_clone ( clone_flags ); p = copy_process ( clone_flags , stack_start , regs , stack_size , child_tidptr , NULL , trace ); /* * Do this prior waking up the new thread - the thread pointer * might get invalid after that point, if the thread exits quickly. */ if ( ! IS_ERR ( p )) { struct completion vfork ; trace_sched_process_fork ( current , p ); nr = task_pid_vnr ( p ); if ( clone_flags & CLONE_PARENT_SETTID ) put_user ( nr , parent_tidptr ); if ( clone_flags & CLONE_VFORK ) { p -> vfork_done = & vfork ; init_completion ( & vfork ); } audit_finish_fork ( p ); tracehook_report_clone ( regs , clone_flags , nr , p ); /* * We set PF_STARTING at creation in case tracing wants to * use this to distinguish a fully live task from one that * hasn't gotten to tracehook_report_clone() yet. Now we * clear it and set the child going. */ p -> flags &= ~ PF_STARTING ; if ( unlikely ( clone_flags & CLONE_STOPPED )) { /* * We'll start up with an immediate SIGSTOP. */ sigaddset ( & p -> pending . signal , SIGSTOP ); set_tsk_thread_flag ( p , TIF_SIGPENDING ); __set_task_state ( p , TASK_STOPPED ); } else { wake_up_new_task ( p , clone_flags ); } tracehook_report_clone_complete ( trace , regs , clone_flags , nr , p ); if ( clone_flags & CLONE_VFORK ) { freezer_do_not_count (); wait_for_completion ( & vfork ); freezer_count (); tracehook_report_vfork_done ( p , nr ); } } else { nr = PTR_ERR ( p ); } return nr ; } do_fork\u51fd\u6570\u901a\u8fc7\u8c03\u7528copy_process\u51fd\u6570\uff0c\u7136\u540e\u8ba9\u8fdb\u7a0b\u5f00\u59cb\u8fd0\u884c\u3002copy_process\u51fd\u6570\u4ee3\u7801\u5982\u4e0b\uff1a /* * This creates a new process as a copy of the old one, * but does not actually start it yet. * * It copies the registers, and all the appropriate * parts of the process environment (as per the clone * flags). The actual kick-off is left to the caller. */ static struct task_struct * copy_process ( unsigned long clone_flags , unsigned long stack_start , struct pt_regs * regs , unsigned long stack_size , int __user * child_tidptr , struct pid * pid , int trace ) { int retval ; struct task_struct * p ; int cgroup_callbacks_done = 0 ; if (( clone_flags & ( CLONE_NEWNS | CLONE_FS )) == ( CLONE_NEWNS | CLONE_FS )) return ERR_PTR ( - EINVAL ); /* * Thread groups must share signals as well, and detached threads * can only be started up within the thread group. */ if (( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND )) return ERR_PTR ( - EINVAL ); /* * Shared signal handlers imply shared VM. By way of the above, * thread groups also imply shared VM. Blocking this case allows * for various simplifications in other code. */ if (( clone_flags & CLONE_SIGHAND ) && ! ( clone_flags & CLONE_VM )) return ERR_PTR ( - EINVAL ); /* * Siblings of global init remain as zombies on exit since they are * not reaped by their parent (swapper). To solve this and to avoid * multi-rooted process trees, prevent global and container-inits * from creating siblings. */ if (( clone_flags & CLONE_PARENT ) && current -> signal -> flags & SIGNAL_UNKILLABLE ) return ERR_PTR ( - EINVAL ); retval = security_task_create ( clone_flags ); if ( retval ) goto fork_out ; retval = - ENOMEM ; p = dup_task_struct ( current ); if ( ! p ) goto fork_out ; ftrace_graph_init_task ( p ); rt_mutex_init_task ( p ); #ifdef CONFIG_PROVE_LOCKING DEBUG_LOCKS_WARN_ON ( ! p -> hardirqs_enabled ); DEBUG_LOCKS_WARN_ON ( ! p -> softirqs_enabled ); #endif \u901a\u8fc7dup_task_struct\u51fd\u6570\u4e3a\u8fdb\u7a0b\u521b\u5efa\u4e00\u4e2a\u5185\u6838\u6808\u3001thread_info\u7ed3\u6784\u548ctask_struct\uff0c\u8fd9\u4e9b\u503c\u4e0e\u5f53\u524d\u8fdb\u7a0b\u7684\u503c\u76f8\u540c\u3002\u6b64\u65f6\uff0c\u5b50\u8fdb\u7a0b\u548c\u7236\u8fdb\u7a0b\u7684\u63cf\u8ff0\u7b26\u662f\u5b8c\u5168\u76f8\u540c\u7684\u3002 retval = - EAGAIN ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= task_rlimit ( p , RLIMIT_NPROC )) { if ( ! capable ( CAP_SYS_ADMIN ) && ! capable ( CAP_SYS_RESOURCE ) && p -> real_cred -> user != INIT_USER ) goto bad_fork_free ; } retval = copy_creds ( p , clone_flags ); if ( retval < 0 ) goto bad_fork_free ; /* * If multiple threads are within copy_process(), then this check * triggers too late. This doesn't hurt, the check is only there * to stop root fork bombs. */ retval = - EAGAIN ; if ( nr_threads >= max_threads ) goto bad_fork_cleanup_count ; if ( ! try_module_get ( task_thread_info ( p ) -> exec_domain -> module )) goto bad_fork_cleanup_count ; \u68c0\u67e5\u5e76\u786e\u4fdd\u65b0\u521b\u5efa\u8fd9\u4e2a\u5b50\u8fdb\u7a0b\u540e\uff0c\u5f53\u524d\u7528\u6237\u6240\u62e5\u6709\u7684\u8fdb\u7a0b\u6570\u76ee\u6ca1\u6709\u8d85\u51fa\u7ed9\u5b83\u5206\u914d\u7684\u8d44\u6e90\u9650\u5236\uff1b p -> did_exec = 0 ; delayacct_tsk_init ( p ); /* Must remain after dup_task_struct() */ copy_flags ( clone_flags , p ); INIT_LIST_HEAD ( & p -> children ); INIT_LIST_HEAD ( & p -> sibling ); rcu_copy_process ( p ); p -> vfork_done = NULL ; spin_lock_init ( & p -> alloc_lock ); init_sigpending ( & p -> pending ); p -> utime = cputime_zero ; p -> stime = cputime_zero ; p -> gtime = cputime_zero ; p -> utimescaled = cputime_zero ; p -> stimescaled = cputime_zero ; #ifndef CONFIG_VIRT_CPU_ACCOUNTING p -> prev_utime = cputime_zero ; p -> prev_stime = cputime_zero ; #endif #if defined(SPLIT_RSS_COUNTING) memset ( & p -> rss_stat , 0 , sizeof ( p -> rss_stat )); #endif p -> default_timer_slack_ns = current -> timer_slack_ns ; task_io_accounting_init ( & p -> ioac ); acct_clear_integrals ( p ); posix_cpu_timers_init ( p ); p -> lock_depth = -1 ; /* -1 = no lock */ do_posix_clock_monotonic_gettime ( & p -> start_time ); p -> real_start_time = p -> start_time ; monotonic_to_bootbased ( & p -> real_start_time ); p -> io_context = NULL ; p -> audit_context = NULL ; cgroup_fork ( p ); #ifdef CONFIG_NUMA p -> mempolicy = mpol_dup ( p -> mempolicy ); if ( IS_ERR ( p -> mempolicy )) { retval = PTR_ERR ( p -> mempolicy ); p -> mempolicy = NULL ; goto bad_fork_cleanup_cgroup ; } mpol_fix_fork_child_flag ( p ); #endif #ifdef CONFIG_TRACE_IRQFLAGS p -> irq_events = 0 ; #ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW p -> hardirqs_enabled = 1 ; #else p -> hardirqs_enabled = 0 ; #endif p -> hardirq_enable_ip = 0 ; p -> hardirq_enable_event = 0 ; p -> hardirq_disable_ip = _THIS_IP_ ; p -> hardirq_disable_event = 0 ; p -> softirqs_enabled = 1 ; p -> softirq_enable_ip = _THIS_IP_ ; p -> softirq_enable_event = 0 ; p -> softirq_disable_ip = 0 ; p -> softirq_disable_event = 0 ; p -> hardirq_context = 0 ; p -> softirq_context = 0 ; #endif #ifdef CONFIG_LOCKDEP p -> lockdep_depth = 0 ; /* no locks held yet */ p -> curr_chain_key = 0 ; p -> lockdep_recursion = 0 ; #endif #ifdef CONFIG_DEBUG_MUTEXES p -> blocked_on = NULL ; /* not blocked yet */ #endif #ifdef CONFIG_CGROUP_MEM_RES_CTLR p -> memcg_batch . do_batch = 0 ; p -> memcg_batch . memcg = NULL ; #endif p -> bts = NULL ; /* Perform scheduler related setup. Assign this task to a CPU. */ sched_fork ( p , clone_flags ); retval = perf_event_init_task ( p ); if ( retval ) goto bad_fork_cleanup_policy ; if (( retval = audit_alloc ( p ))) goto bad_fork_cleanup_policy ; /* copy all the process information */ if (( retval = copy_semundo ( clone_flags , p ))) goto bad_fork_cleanup_audit ; if (( retval = copy_files ( clone_flags , p ))) goto bad_fork_cleanup_semundo ; if (( retval = copy_fs ( clone_flags , p ))) goto bad_fork_cleanup_files ; if (( retval = copy_sighand ( clone_flags , p ))) goto bad_fork_cleanup_fs ; if (( retval = copy_signal ( clone_flags , p ))) goto bad_fork_cleanup_sighand ; if (( retval = copy_mm ( clone_flags , p ))) goto bad_fork_cleanup_signal ; if (( retval = copy_namespaces ( clone_flags , p ))) goto bad_fork_cleanup_mm ; if (( retval = copy_io ( clone_flags , p ))) goto bad_fork_cleanup_namespaces ; retval = copy_thread ( clone_flags , stack_start , stack_size , p , regs ); if ( retval ) goto bad_fork_cleanup_io ; if ( pid != & init_struct_pid ) { retval = - ENOMEM ; pid = alloc_pid ( p -> nsproxy -> pid_ns ); if ( ! pid ) goto bad_fork_cleanup_io ; if ( clone_flags & CLONE_NEWPID ) { retval = pid_ns_prepare_proc ( p -> nsproxy -> pid_ns ); if ( retval < 0 ) goto bad_fork_free_pid ; } } p -> pid = pid_nr ( pid ); p -> tgid = p -> pid ; if ( clone_flags & CLONE_THREAD ) p -> tgid = current -> tgid ; if ( current -> nsproxy != p -> nsproxy ) { retval = ns_cgroup_clone ( p , pid ); if ( retval ) goto bad_fork_free_pid ; } \u8c03\u7528alloc_pid()\u4e3a\u65b0\u8fdb\u7a0b\u5206\u914d\u4e00\u4e2a\u6709\u6548\u7684PID p -> set_child_tid = ( clone_flags & CLONE_CHILD_SETTID ) ? child_tidptr : NULL ; /* * Clear TID on mm_release()? */ p -> clear_child_tid = ( clone_flags & CLONE_CHILD_CLEARTID ) ? child_tidptr : NULL ; #ifdef CONFIG_FUTEX p -> robust_list = NULL ; #ifdef CONFIG_COMPAT p -> compat_robust_list = NULL ; #endif INIT_LIST_HEAD ( & p -> pi_state_list ); p -> pi_state_cache = NULL ; #endif /* * sigaltstack should be cleared when sharing the same VM */ if (( clone_flags & ( CLONE_VM | CLONE_VFORK )) == CLONE_VM ) p -> sas_ss_sp = p -> sas_ss_size = 0 ; /* * Syscall tracing and stepping should be turned off in the * child regardless of CLONE_PTRACE. */ user_disable_single_step ( p ); clear_tsk_thread_flag ( p , TIF_SYSCALL_TRACE ); #ifdef TIF_SYSCALL_EMU clear_tsk_thread_flag ( p , TIF_SYSCALL_EMU ); #endif clear_all_latency_tracing ( p ); /* ok, now we should be set up.. */ p -> exit_signal = ( clone_flags & CLONE_THREAD ) ? -1 : ( clone_flags & CSIGNAL ); p -> pdeath_signal = 0 ; p -> exit_state = 0 ; /* * Ok, make it visible to the rest of the system. * We dont wake it up yet. */ p -> group_leader = p ; INIT_LIST_HEAD ( & p -> thread_group ); /* Now that the task is set up, run cgroup callbacks if * necessary. We need to run them before the task is visible * on the tasklist. */ cgroup_fork_callbacks ( p ); cgroup_callbacks_done = 1 ; /* Need tasklist lock for parent etc handling! */ write_lock_irq ( & tasklist_lock ); /* CLONE_PARENT re-uses the old parent */ if ( clone_flags & ( CLONE_PARENT | CLONE_THREAD )) { p -> real_parent = current -> real_parent ; p -> parent_exec_id = current -> parent_exec_id ; } else { p -> real_parent = current ; p -> parent_exec_id = current -> self_exec_id ; } spin_lock ( & current -> sighand -> siglock ); /* * Process group and session signals need to be delivered to just the * parent before the fork or both the parent and the child after the * fork. Restart if a signal comes in before we add the new process to * it's process group. * A fatal signal pending means that current will exit, so the new * thread can't slip out of an OOM kill (or normal SIGKILL). */ recalc_sigpending (); if ( signal_pending ( current )) { spin_unlock ( & current -> sighand -> siglock ); write_unlock_irq ( & tasklist_lock ); retval = - ERESTARTNOINTR ; goto bad_fork_free_pid ; } if ( clone_flags & CLONE_THREAD ) { atomic_inc ( & current -> signal -> count ); atomic_inc ( & current -> signal -> live ); p -> group_leader = current -> group_leader ; list_add_tail_rcu ( & p -> thread_group , & p -> group_leader -> thread_group ); } if ( likely ( p -> pid )) { tracehook_finish_clone ( p , clone_flags , trace ); if ( thread_group_leader ( p )) { if ( clone_flags & CLONE_NEWPID ) p -> nsproxy -> pid_ns -> child_reaper = p ; p -> signal -> leader_pid = pid ; tty_kref_put ( p -> signal -> tty ); p -> signal -> tty = tty_kref_get ( current -> signal -> tty ); attach_pid ( p , PIDTYPE_PGID , task_pgrp ( current )); attach_pid ( p , PIDTYPE_SID , task_session ( current )); list_add_tail ( & p -> sibling , & p -> real_parent -> children ); list_add_tail_rcu ( & p -> tasks , & init_task . tasks ); __get_cpu_var ( process_counts ) ++ ; } attach_pid ( p , PIDTYPE_PID , pid ); nr_threads ++ ; } total_forks ++ ; spin_unlock ( & current -> sighand -> siglock ); write_unlock_irq ( & tasklist_lock ); proc_fork_connector ( p ); cgroup_post_fork ( p ); perf_event_fork ( p ); return p ; \u626b\u5c3e\u5de5\u4f5c\u5e76\u8fd4\u56de\u4e00\u4e2a\u6307\u5411\u5b50\u8fdb\u7a0b\u7684\u6307\u9488\uff1b bad_fork_free_pid : if ( pid != & init_struct_pid ) free_pid ( pid ); bad_fork_cleanup_io : if ( p -> io_context ) exit_io_context ( p ); bad_fork_cleanup_namespaces : exit_task_namespaces ( p ); bad_fork_cleanup_mm : if ( p -> mm ) mmput ( p -> mm ); bad_fork_cleanup_signal : if ( ! ( clone_flags & CLONE_THREAD )) __cleanup_signal ( p -> signal ); bad_fork_cleanup_sighand : __cleanup_sighand ( p -> sighand ); bad_fork_cleanup_fs : exit_fs ( p ); /* blocking */ bad_fork_cleanup_files : exit_files ( p ); /* blocking */ bad_fork_cleanup_semundo : exit_sem ( p ); bad_fork_cleanup_audit : audit_free ( p ); bad_fork_cleanup_policy : perf_event_free_task ( p ); #ifdef CONFIG_NUMA mpol_put ( p -> mempolicy ); bad_fork_cleanup_cgroup : #endif cgroup_exit ( p , cgroup_callbacks_done ); delayacct_tsk_free ( p ); module_put ( task_thread_info ( p ) -> exec_domain -> module ); bad_fork_cleanup_count : atomic_dec ( & p -> cred -> user -> processes ); exit_creds ( p ); bad_fork_free : free_task ( p ); fork_out : return ERR_PTR ( retval ); } \u6545\u969c\u5904\u7406\uff1b \u521b\u5efa\u7ebf\u7a0b \u00b6 \u7ebf\u7a0b\u7684\u521b\u5efa\u548c\u666e\u901a\u8fdb\u7a0b\u521b\u5efa\u7c7b\u4f3c\uff0c\u4e0d\u8fc7\u5728\u8c03\u7528clone()\u7684\u65f6\u5019\u9700\u8981\u4f20\u9012\u4e00\u4e9b\u53c2\u6570\u6807\u5fd7\u6765\u6307\u660e\u9700\u8981\u5171\u4eab\u7684\u8d44\u6e90 clone ( CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND , 0 ) \u5bf9\u6bd4\u4e00\u4e2a\u666e\u901a\u7684fork\u5b9e\u73b0\u5982\u4e0b\uff1a clone ( SIGCHLD , 0 ); \u800cvfork\u7684\u5b9e\u73b0\u5982\u4e0b\uff1a clone ( CLONE_VFORK | CLONE_VM | SIGCHLD , 0 ); \u5185\u6838\u7ebf\u7a0b\u542f\u52a8\u540e\u5c31\u4e00\u76f4\u8fd0\u884c\u76f4\u5230\u8c03\u7528do_exit()\u9000\u51fa\uff0c\u6216\u8005\u5185\u6838\u7684\u5176\u4ed6\u90e8\u5206\u8c03\u7528kthread_stop()\u9000\u51fa\uff0c\u4f20\u9012\u7ed9kthread_stop()\u7684\u53c2\u6570\u4e3akthread_create()\u7684\u51fd\u6570\u8fd4\u56de\u7684task_struct\u7ed3\u6784\u7684\u5730\u5740\uff1a int kthread_stop(struct task_struct *k)","title":"\u8fdb\u7a0b\u521b\u5efa"},{"location":"%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/#_1","text":"\u7ebf\u7a0b\u7684\u521b\u5efa\u548c\u666e\u901a\u8fdb\u7a0b\u521b\u5efa\u7c7b\u4f3c\uff0c\u4e0d\u8fc7\u5728\u8c03\u7528clone()\u7684\u65f6\u5019\u9700\u8981\u4f20\u9012\u4e00\u4e9b\u53c2\u6570\u6807\u5fd7\u6765\u6307\u660e\u9700\u8981\u5171\u4eab\u7684\u8d44\u6e90 clone ( CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND , 0 ) \u5bf9\u6bd4\u4e00\u4e2a\u666e\u901a\u7684fork\u5b9e\u73b0\u5982\u4e0b\uff1a clone ( SIGCHLD , 0 ); \u800cvfork\u7684\u5b9e\u73b0\u5982\u4e0b\uff1a clone ( CLONE_VFORK | CLONE_VM | SIGCHLD , 0 ); \u5185\u6838\u7ebf\u7a0b\u542f\u52a8\u540e\u5c31\u4e00\u76f4\u8fd0\u884c\u76f4\u5230\u8c03\u7528do_exit()\u9000\u51fa\uff0c\u6216\u8005\u5185\u6838\u7684\u5176\u4ed6\u90e8\u5206\u8c03\u7528kthread_stop()\u9000\u51fa\uff0c\u4f20\u9012\u7ed9kthread_stop()\u7684\u53c2\u6570\u4e3akthread_create()\u7684\u51fd\u6570\u8fd4\u56de\u7684task_struct\u7ed3\u6784\u7684\u5730\u5740\uff1a int kthread_stop(struct task_struct *k)","title":"\u521b\u5efa\u7ebf\u7a0b"},{"location":"%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E5%AE%B6%E6%97%8F%E6%A0%91/","text":"Linux\u7cfb\u7edf\u4e2d\uff0c\u6240\u6709\u8fdb\u7a0b\u90fd\u662fPID\u4e3a1\u7684init\u8fdb\u7a0b\u7684\u540e\u4ee3\u3002\u5185\u6838\u5728\u7cfb\u7edf\u542f\u52a8\u7684\u6700\u540e\u9636\u6bb5\u542f\u52a8init\u8fdb\u7a0b\u3002\u8be5\u8fdb\u7a0b\u8bfb\u53d6\u7cfb\u7edf\u7684\u521d\u59cb\u5316\u811a\u672c\uff08initscript\uff09\u5e76\u6267\u884c\u5176\u4ed6\u7684\u76f8\u5173\u7a0b\u5e8f\uff0c\u6700\u7ec8\u5b8c\u6210\u7cfb\u7edf\u542f\u52a8\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002 \u5373\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u4ee3\u7801\u83b7\u53d6\u5230init\u8fdb\u7a0b\uff1a struct task_struct * task ; for ( task = current ; task != & init_task ; task = task -> parent ); /*task\u73b0\u5728\u6307\u5411init*/ \u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e2a\u8fdb\u7a0b\u5fc5\u6709\u4e00\u4e2a\u7236\u8fdb\u7a0b\uff0c\u76f8\u5e94\u7684\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u4e5f\u53ef\u4ee5\u62e5\u6709\u96f6\u4e2a\u6216\u591a\u4e2a\u5b50\u8fdb\u7a0b\u3002\u62e5\u6709\u540c\u4e00\u4e2a\u7236\u8fdb\u7a0b\u7684\u6240\u6709\u8fdb\u7a0b\u88ab\u79f0\u4e3a\u5144\u5f1f\u3002\u8fdb\u7a0b\u95f4\u7684\u5173\u7cfb\u5b58\u653e\u5728\u8fdb\u7a0b\u63cf\u8ff0\u7b26\u4e2d\u3002\u6bcf\u4e2atask_struct\u90fd\u5305\u542b\u4e00\u4e2a\u6307\u5411\u5176\u7236\u8fdb\u7a0btast_struct\u3001\u53eb\u505aparent\u7684\u6307\u9488\uff0c\u8fd8\u5305\u542b\u4e00\u4e2a\u79f0\u4e3achildren\u7684\u5b50\u8fdb\u7a0b\u94fe\u8868\u3002\u5bf9\u4e8e\u5f53\u524d\u8fdb\u7a0b\uff0c\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u64cd\u4f5c\u83b7\u53d6\u5176\u7236\u8fdb\u7a0b\u7684\u8fdb\u7a0b\u63cf\u8ff0\u7b26\uff1a struct task_struct * my_parent = current -> parent ; \u540c\u65f6\u4e5f\u53ef\u4ee5\u6309\u7167\u4ee5\u4e0b\u65b9\u6cd5\u8bbf\u95ee\u5b50\u8fdb\u7a0b\uff1a struct task_struct * task ; struct list_head * list ; list_for_each ( list , & current -> children ){ task = list_entry ( list , struct task_struct , sibling ); /* task \u73b0\u5728\u6307\u5411\u5f53\u524d\u7684\u67d0\u4e2a\u5b50\u8fdb\u7a0b */ } list_for_each \u662flinux\u6e90\u7801\u4e2d\u7684\u5b8f\u5b9a\u4e49\uff08./include/linux/list.h\uff09\uff0c\u5176\u5b9a\u4e49\u5982\u4e0b\uff1a #define list_for_each(pos, head) \\ for (pos = (head)->next; prefetch(pos->next), pos != (head); \\ pos = pos->next) #define prefetch(x) __builtin_prefetch(x) //(./include/linux/prefetch.h) \u56e0\u4e3a\u4efb\u52a1\u961f\u5217\u662f\u4e00\u4e2a\u53cc\u5411\u5faa\u73af\u7684\u94fe\u8868\uff0c\u6240\u4ee5\u53ef\u4ee5\u5f88\u5bb9\u6613\u7684\u4ece\u4e00\u4e2a\u8fdb\u7a0b\u904d\u5386\u73a9\u6240\u6709\u8fdb\u7a0b\u3002 \u5bf9\u4e8e\u7ed9\u5b9a\u7684\u8fdb\u7a0b\uff0c\u83b7\u53d6\u94fe\u8868\u4e2d\u7684\u4e0b\u4e00\u4e2a\u8fdb\u7a0b\u548c\u4e0a\u4e00\u4e2a\u8fdb\u7a0b\u7684\u4ee3\u7801\u5982\u4e0b\uff1a list_entry ( task -> task . next , struct task_struct , tasks ) //\u83b7\u53d6\u4e0b\u4e00\u4e2a\u8fdb\u7a0b list_entry ( task -> task . prev , struct task_struct , tasks ) //\u83b7\u53d6\u4e0a\u4e00\u4e2a\u8fdb\u7a0b \u4ee5\u4e0a\u4ee3\u7801\u901a\u8fc7next_task(task)\u5b8f\u548cprev_task(task)\u5b8f\u5b9a\u4e49\u4e86\u3002 \u5176\u4e2dlist_entry\u662f\u4e00\u4e2a\u901a\u8fc7\u7ed3\u6784\u4f53\u5185\u90e8\u7684list\u6210\u5458\u53d8\u91cf\u83b7\u53d6\u7ed3\u6784\u4f53\u6307\u9488\u7684\u795e\u5947\u5b8f\u5b9a\u4e49\uff0c\u5176\u5185\u5bb9\u5982\u4e0b\uff1a // ./include/linux/list.h /** * list_entry - get the struct for this entry * @ptr: the &struct list_head pointer. * @type: the type of the struct this is embedded in. * @member: the name of the list_struct within the struct. */ #define list_entry(ptr, type, member) \\ container_of(ptr, type, member) // ./include/linux/kernel.h /** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * */ #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)->member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) \u540c\u65f6\uff0cfor_each_process(task)\u5b8f\u63d0\u4f9b\u4e86\u4f9d\u6b21\u8bbf\u95ee\u6574\u4e2a\u4efb\u52a1\u961f\u5217\u7684\u80fd\u529b\u3002\u6bcf\u6b21\u8bbf\u95ee\uff0c\u4efb\u52a1\u6307\u9488\u90fd\u6307\u5411\u94fe\u8868\u4e2d\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20(./include/linux/sched.h) #define for_each_process(p) \\ for (p = &init_task ; (p = next_task(p)) != &init_task ; ) __builtin_prefetch() \u662f gcc \u7684\u4e00\u4e2a\u5185\u7f6e\u51fd\u6570\u3002\u5b83\u901a\u8fc7\u5bf9\u6570\u636e\u624b\u5de5\u9884\u53d6\u7684\u65b9\u6cd5\uff0c\u51cf\u5c11\u4e86\u8bfb\u53d6\u5ef6\u8fdf\uff0c\u4ece\u800c\u63d0\u9ad8\u4e86\u6027\u80fd\uff0c\u4f46\u8be5\u51fd\u6570\u4e5f\u9700\u8981 CPU \u7684\u652f\u6301\u3002 \u8be5\u51fd\u6570\u539f\u578b\u4e3a\uff1a void __builtin_prefetch ( const void * addr , ...) \u5176\u4e2d\u53c2\u6570 addr \u662f\u4e2a\u5185\u5b58\u6307\u9488\uff0c\u5b83\u6307\u5411\u8981\u9884\u53d6\u7684\u6570\u636e\uff0c\u6211\u4eec\u4eba\u5de5\u9700\u8981\u5224\u5b9a\u8fd9\u4e9b\u6570\u636e\u662f\u5f88\u5feb\u80fd\u8bbf\u95ee\u5230\u7684\uff0c\u6216\u8005\u8bf4\u662f\u5b83\u4eec\u5c31\u5728\u6700\u8fd1\u7684\u5185\u5b58\u4e2d --- \u4e00\u822c\u6765\u8bf4\uff0c\u5bf9\u4e8e\u94fe\u8868\u800c\u8a00\uff0c\u5404\u4e2a\u8282\u70b9\u5728\u5185\u5b58\u4e2d\u57fa\u672c\u4e0a\u662f\u7d27\u6328\u7740\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u5bb9\u6613\u9884\u53d6\u94fe\u8868\u8282\u70b9\u91cc\u7684\u6307\u9488\u9879\u3002 \u8be5\u51fd\u6570\u8fd8\u6709\u4e24\u4e2a\u53ef\u9009\u53c2\u6570\uff0crw \u548c locality \u3002 rw \u662f\u4e2a\u7f16\u8bd1\u65f6\u7684\u5e38\u6570\uff0c\u6216 1 \u6216 0 \u30021 \u65f6\u8868\u793a\u5199(w)\uff0c0 \u65f6\u8868\u793a\u8bfb\u00ae \u3002 locality \u5fc5\u987b\u662f\u7f16\u8bd1\u65f6\u7684\u5e38\u6570\uff0c\u4e5f\u79f0\u4e3a\u201c\u65f6\u95f4\u5c40\u90e8\u6027\u201d(temporal locality) \u3002\u65f6\u95f4\u5c40\u90e8\u6027\u662f\u6307\uff0c\u5982\u679c\u7a0b\u5e8f\u4e2d\u67d0\u4e00\u6761\u6307\u4ee4\u4e00\u65e6\u6267\u884c\uff0c\u5219\u4e0d\u4e45\u4e4b\u540e\u8be5\u6307\u4ee4\u53ef\u80fd\u518d\u88ab\u6267\u884c\uff1b\u5982\u679c\u67d0\u6570\u636e\u88ab\u8bbf\u95ee\uff0c\u5219\u4e0d\u4e45\u4e4b\u540e\u8be5\u6570\u636e\u4f1a\u88ab\u518d\u6b21\u8bbf\u95ee\u3002\u8be5\u503c\u7684\u8303\u56f4\u5728 0 - 3 \u4e4b\u95f4\u3002\u4e3a 0 \u65f6\u8868\u793a\uff0c\u5b83\u6ca1\u6709\u65f6\u95f4\u5c40\u90e8\u6027\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u8981\u8bbf\u95ee\u7684\u6570\u636e\u6216\u5730\u5740\u88ab\u8bbf\u95ee\u4e4b\u540e\u7684\u4e0d\u957f\u7684\u65f6\u95f4\u91cc\u4e0d\u4f1a\u518d\u88ab\u8bbf\u95ee\uff1b\u4e3a 3 \u65f6\u8868\u793a\uff0c\u88ab\u8bbf\u95ee\u7684\u6570\u636e\u6216\u5730\u5740\u5177\u6709\u9ad8 \u65f6\u95f4\u5c40\u90e8\u6027\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5728\u88ab\u8bbf\u95ee\u4e0d\u4e45\u4e4b\u540e\u975e\u5e38\u6709\u53ef\u80fd\u518d\u6b21\u8bbf\u95ee\uff1b\u5bf9\u4e8e\u503c 1 \u548c 2\uff0c\u5219\u5206\u522b\u8868\u793a\u5177\u6709\u4f4e \u65f6\u95f4\u5c40\u90e8\u6027 \u548c\u4e2d\u7b49 \u65f6\u95f4\u5c40\u90e8\u6027\u3002\u8be5\u503c\u9ed8\u8ba4\u4e3a 3 \u3002 \u91c7\u7528\u5982\u4e0b\u4ee3\u7801\u8fdb\u884c\u6d4b\u8bd5\uff0c\u4f7f\u7528O0\u4f18\u5316\u8fdb\u884c\u7f16\u8bd1\uff0c\u4f7f\u7528linux\u4e0b\u4f7f\u7528time\u547d\u4ee4\u67e5\u770b\u7a0b\u5e8f\u7684\u6267\u884c\u65f6\u95f4\uff1a #include <stdio.h> #include <unistd.h> int main ( int argc , int * arg ) { int a [ 10 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; int b [ 10 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; int temp ; int i , j ; for ( i = 0 ; i < 100000000 ; i ++ ) { for ( j = 0 ; j < 10 ; j ++ ) { //\u8fdb\u884c\u4e00\u5b9a\u6b21\u6570\u7684\u64cd\u4f5c a [ j ] = a [ j ] + b [ j ]; a [ j ] = a [ j ] + b [ j ]; a [ j ] = a [ j ] + b [ j ]; //... //\u9884\u83b7\u53d6\u547d\u4ee4 __builtin_prefetch ( & a [ j + 1 ], 1 , 3 ); __builtin_prefetch ( & b [ j + 1 ], 0 , 3 ); } } return 0 ; } \u4ee5\u4e0b\u662f\u5728vbox\u7684ubuntu\u865a\u62df\u673a\u4e2d\u5b9e\u9a8c\u83b7\u53d6\u7684\u6570\u636e\uff1a \u6b21\u6570 \u6709\u9884\u83b7\u53d6 \u65e0\u9884\u83b7\u53d6 1 5.257s 4.643s 2 5.566s 6.040s 3 6.152s 6.401s 4 7.355s 7.531s 5 8.890s 10.233s 6 10.122s 10.130s 7 12.342s 12.368s 8 13.360s 12.554s","title":"\u8fdb\u7a0b\u5bb6\u65cf\u6811"},{"location":"%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6/","text":"1 \u8fdb\u7a0b\u63cf\u8ff0\u7b26\u7684\u7ed3\u6784 \u00b6 \u5185\u6838\u628a\u8fdb\u7a0b\u7684\u5217\u8868\u5b58\u653e\u5728\u53eb\u505a\u4efb\u52a1\u961f\u5217\uff08task list\uff09\u7684\u53cc\u5411\u5faa\u73af\u94fe\u8868\u4e2d\u3002\u94fe\u8868\u4e2d\u7684\u6bcf\u4e00\u9879\u90fd\u662f\u7c7b\u578b\u4e3a task_struct \u7684\u8fdb\u7a0b\u63cf\u8ff0\u7b26\u7ed3\u6784\uff0c\u8be5\u7ed3\u6784\u5b9a\u4e49\u5728 \u6587\u4ef6\u4e2d\uff08./include/linux/sched.h)\u3002\u8fdb\u7a0b\u63cf\u8ff0\u7b26\u5305\u542b\u4e86\u4e00\u4e2a\u5177\u4f53\u8fdb\u7a0b\u7684\u6240\u6709\u4fe1\u606f\u3002 struct task_struct { volatile long state ; /* -1 unrunnable, 0 runnable, >0 stopped */ void * stack ; atomic_t usage ; unsigned int flags ; /* per process flags, defined below */ unsigned int ptrace ; int lock_depth ; /* BKL lock depth */ #ifdef CONFIG_SMP #ifdef __ARCH_WANT_UNLOCKED_CTXSW int oncpu ; #endif #endif int prio , static_prio , normal_prio ; unsigned int rt_priority ; const struct sched_class * sched_class ; struct sched_entity se ; struct sched_rt_entity rt ; #ifdef CONFIG_PREEMPT_NOTIFIERS /* list of struct preempt_notifier: */ struct hlist_head preempt_notifiers ; #endif /* * fpu_counter contains the number of consecutive context switches * that the FPU is used. If this is over a threshold, the lazy fpu * saving becomes unlazy to save the trap. This is an unsigned char * so that after 256 times the counter wraps and the behavior turns * lazy again; this to deal with bursty apps that only use FPU for * a short time */ unsigned char fpu_counter ; #ifdef CONFIG_BLK_DEV_IO_TRACE unsigned int btrace_seq ; #endif unsigned int policy ; cpumask_t cpus_allowed ; #ifdef CONFIG_TREE_PREEMPT_RCU int rcu_read_lock_nesting ; char rcu_read_unlock_special ; struct rcu_node * rcu_blocked_node ; struct list_head rcu_node_entry ; #endif /* #ifdef CONFIG_TREE_PREEMPT_RCU */ #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) struct sched_info sched_info ; #endif struct list_head tasks ; struct plist_node pushable_tasks ; struct mm_struct * mm , * active_mm ; #if defined(SPLIT_RSS_COUNTING) struct task_rss_stat rss_stat ; #endif /* task state */ int exit_state ; int exit_code , exit_signal ; int pdeath_signal ; /* The signal sent when the parent dies */ /* ??? */ unsigned int personality ; unsigned did_exec : 1 ; unsigned in_execve : 1 ; /* Tell the LSMs that the process is doing an * execve */ unsigned in_iowait : 1 ; /* Revert to default priority/policy when forking */ unsigned sched_reset_on_fork : 1 ; pid_t pid ; pid_t tgid ; #ifdef CONFIG_CC_STACKPROTECTOR /* Canary value for the -fstack-protector gcc feature */ unsigned long stack_canary ; #endif /* * pointers to (original) parent process, youngest child, younger sibling, * older sibling, respectively. (p->father can be replaced with * p->real_parent->pid) */ struct task_struct * real_parent ; /* real parent process */ struct task_struct * parent ; /* recipient of SIGCHLD, wait4() reports */ /* * children/sibling forms the list of my natural children */ struct list_head children ; /* list of my children */ struct list_head sibling ; /* linkage in my parent's children list */ struct task_struct * group_leader ; /* threadgroup leader */ /* * ptraced is the list of tasks this task is using ptrace on. * This includes both natural children and PTRACE_ATTACH targets. * p->ptrace_entry is p's link on the p->parent->ptraced list. */ struct list_head ptraced ; struct list_head ptrace_entry ; /* * This is the tracer handle for the ptrace BTS extension. * This field actually belongs to the ptracer task. */ struct bts_context * bts ; /* PID/PID hash table linkage. */ struct pid_link pids [ PIDTYPE_MAX ]; struct list_head thread_group ; struct completion * vfork_done ; /* for vfork() */ int __user * set_child_tid ; /* CLONE_CHILD_SETTID */ int __user * clear_child_tid ; /* CLONE_CHILD_CLEARTID */ cputime_t utime , stime , utimescaled , stimescaled ; cputime_t gtime ; #ifndef CONFIG_VIRT_CPU_ACCOUNTING cputime_t prev_utime , prev_stime ; #endif unsigned long nvcsw , nivcsw ; /* context switch counts */ struct timespec start_time ; /* monotonic time */ struct timespec real_start_time ; /* boot based time */ /* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */ unsigned long min_flt , maj_flt ; struct task_cputime cputime_expires ; struct list_head cpu_timers [ 3 ]; /* process credentials */ const struct cred * real_cred ; /* objective and real subjective task * credentials (COW) */ const struct cred * cred ; /* effective (overridable) subjective task * credentials (COW) */ struct mutex cred_guard_mutex ; /* guard against foreign influences on * credential calculations * (notably. ptrace) */ struct cred * replacement_session_keyring ; /* for KEYCTL_SESSION_TO_PARENT */ char comm [ TASK_COMM_LEN ]; /* executable name excluding path - access with [gs]et_task_comm (which lock it with task_lock()) - initialized normally by setup_new_exec */ /* file system info */ int link_count , total_link_count ; #ifdef CONFIG_SYSVIPC /* ipc stuff */ struct sysv_sem sysvsem ; #endif #ifdef CONFIG_DETECT_HUNG_TASK /* hung task detection */ unsigned long last_switch_count ; #endif /* CPU-specific state of this task */ struct thread_struct thread ; /* filesystem information */ struct fs_struct * fs ; /* open file information */ struct files_struct * files ; /* namespaces */ struct nsproxy * nsproxy ; /* signal handlers */ struct signal_struct * signal ; struct sighand_struct * sighand ; sigset_t blocked , real_blocked ; sigset_t saved_sigmask ; /* restored if set_restore_sigmask() was used */ struct sigpending pending ; unsigned long sas_ss_sp ; size_t sas_ss_size ; int ( * notifier )( void * priv ); void * notifier_data ; sigset_t * notifier_mask ; struct audit_context * audit_context ; #ifdef CONFIG_AUDITSYSCALL uid_t loginuid ; unsigned int sessionid ; #endif seccomp_t seccomp ; /* Thread group tracking */ u32 parent_exec_id ; u32 self_exec_id ; /* Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed, * mempolicy */ spinlock_t alloc_lock ; #ifdef CONFIG_GENERIC_HARDIRQS /* IRQ handler threads */ struct irqaction * irqaction ; #endif /* Protection of the PI data structures: */ raw_spinlock_t pi_lock ; #ifdef CONFIG_RT_MUTEXES /* PI waiters blocked on a rt_mutex held by this task */ struct plist_head pi_waiters ; /* Deadlock detection and priority inheritance handling */ struct rt_mutex_waiter * pi_blocked_on ; #endif #ifdef CONFIG_DEBUG_MUTEXES /* mutex deadlock detection */ struct mutex_waiter * blocked_on ; #endif #ifdef CONFIG_TRACE_IRQFLAGS unsigned int irq_events ; unsigned long hardirq_enable_ip ; unsigned long hardirq_disable_ip ; unsigned int hardirq_enable_event ; unsigned int hardirq_disable_event ; int hardirqs_enabled ; int hardirq_context ; unsigned long softirq_disable_ip ; unsigned long softirq_enable_ip ; unsigned int softirq_disable_event ; unsigned int softirq_enable_event ; int softirqs_enabled ; int softirq_context ; #endif #ifdef CONFIG_LOCKDEP # define MAX_LOCK_DEPTH 48UL u64 curr_chain_key ; int lockdep_depth ; unsigned int lockdep_recursion ; struct held_lock held_locks [ MAX_LOCK_DEPTH ]; gfp_t lockdep_reclaim_gfp ; #endif /* journalling filesystem info */ void * journal_info ; /* stacked block device info */ struct bio_list * bio_list ; /* VM state */ struct reclaim_state * reclaim_state ; struct backing_dev_info * backing_dev_info ; struct io_context * io_context ; unsigned long ptrace_message ; siginfo_t * last_siginfo ; /* For ptrace use. */ struct task_io_accounting ioac ; #if defined(CONFIG_TASK_XACCT) u64 acct_rss_mem1 ; /* accumulated rss usage */ u64 acct_vm_mem1 ; /* accumulated virtual memory usage */ cputime_t acct_timexpd ; /* stime + utime since last update */ #endif #ifdef CONFIG_CPUSETS nodemask_t mems_allowed ; /* Protected by alloc_lock */ int cpuset_mem_spread_rotor ; #endif #ifdef CONFIG_CGROUPS /* Control Group info protected by css_set_lock */ struct css_set * cgroups ; /* cg_list protected by css_set_lock and tsk->alloc_lock */ struct list_head cg_list ; #endif #ifdef CONFIG_FUTEX struct robust_list_head __user * robust_list ; #ifdef CONFIG_COMPAT struct compat_robust_list_head __user * compat_robust_list ; #endif struct list_head pi_state_list ; struct futex_pi_state * pi_state_cache ; #endif #ifdef CONFIG_PERF_EVENTS struct perf_event_context * perf_event_ctxp ; struct mutex perf_event_mutex ; struct list_head perf_event_list ; #endif #ifdef CONFIG_NUMA struct mempolicy * mempolicy ; /* Protected by alloc_lock */ short il_next ; #endif atomic_t fs_excl ; /* holding fs exclusive resources */ struct rcu_head rcu ; /* * cache last used pipe for splice */ struct pipe_inode_info * splice_pipe ; #ifdef CONFIG_TASK_DELAY_ACCT struct task_delay_info * delays ; #endif #ifdef CONFIG_FAULT_INJECTION int make_it_fail ; #endif struct prop_local_single dirties ; #ifdef CONFIG_LATENCYTOP int latency_record_count ; struct latency_record latency_record [ LT_SAVECOUNT ]; #endif /* * time slack values; these are used to round up poll() and * select() etc timeout values. These are in nanoseconds. */ unsigned long timer_slack_ns ; unsigned long default_timer_slack_ns ; struct list_head * scm_work_list ; #ifdef CONFIG_FUNCTION_GRAPH_TRACER /* Index of current stored address in ret_stack */ int curr_ret_stack ; /* Stack of return addresses for return function tracing */ struct ftrace_ret_stack * ret_stack ; /* time stamp for last schedule */ unsigned long long ftrace_timestamp ; /* * Number of functions that haven't been traced * because of depth overrun. */ atomic_t trace_overrun ; /* Pause for the tracing */ atomic_t tracing_graph_pause ; #endif #ifdef CONFIG_TRACING /* state flags for use by tracers */ unsigned long trace ; /* bitmask of trace recursion */ unsigned long trace_recursion ; #endif /* CONFIG_TRACING */ #ifdef CONFIG_CGROUP_MEM_RES_CTLR /* memcg uses this to do batch job */ struct memcg_batch_info { int do_batch ; /* incremented when batch uncharge started */ struct mem_cgroup * memcg ; /* target memcg of uncharge */ unsigned long bytes ; /* uncharged usage */ unsigned long memsw_bytes ; /* uncharged mem+swap usage */ } memcg_batch ; #endif }; 2 \u8fdb\u7a0b\u63cf\u8ff0\u7b26\u7684\u5b58\u653e \u00b6 Linux\u901a\u8fc7slab\u5206\u914d\u5668\u5206\u914dtask_struct\u7ed3\u6784\uff0c\u8fd9\u6837\u80fd\u8fbe\u5230\u5bf9\u8c61\u590d\u7528\u548c\u7f13\u5b58\u7740\u8272\u5668\uff08cache \u3001coloring\uff09\u7684\u76ee\u7684\u3002\u57282.6\u4ee5\u524d\u7684\u5185\u6838\u4e2d\uff0c\u5404\u4e2a\u8fdb\u7a0b\u7684task_struct\u5b58\u653e\u5728\u5b83\u4eec\u5185\u6838\u6808\u7684\u5c3e\u7aef\u3002\u8fd9\u6837\u505a\u662f\u4e3a\u4e86\u8ba9\u90a3\u4e9b\u50cfx86\u90a3\u6837\u5bc4\u5b58\u5668\u8f83\u5c11\u7684\u786c\u4ef6\u4f53\u7cfb\u7ed3\u6784\u53ea\u8981\u901a\u8fc7\u6808\u6307\u9488\u5c31\u80fd\u8ba1\u7b97\u51fa\u5b83\u7684\u4f4d\u7f6e\uff0c\u800c\u907f\u514d\u4f7f\u7528\u989d\u5916\u7684\u5bc4\u5b58\u5668\u4e13\u95e8\u8bb0\u5f55\u3002\u7531\u4e8e\u73b0\u5728\u7528slab\u5206\u914d\u5668\u52a8\u6001\u751f\u6210task_struct\uff0c\u6240\u4ee5\u53ea\u9700\u5728\u6808\u5e95\uff08\u5bf9\u4e8e\u5411\u4e0b\u589e\u957f\u7684\u6808\u6765\u8bf4\uff09\u6216\u6808\u9876\uff08\u5bf9\u4e8e\u5411\u4e0a\u589e\u957f\u7684\u6808\u6765\u8bf4\uff09\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7ed3\u6784struct thread_info \u3002 \u6bcf\u4e2a\u4efb\u52a1\u7684thread_info\u7ed3\u6784\u5728\u5b83\u7684\u5185\u6838\u7684\u5c3e\u7aef\u5206\u914d\u3002\u7ed3\u6784\u4e2dtask\u57df\u4e2d\u5b58\u653e\u7684\u662f\u6307\u5411\u8be5\u4efb\u52a1\u5b9e\u9645task_struct\u7684\u6307\u9488\u3002 \u5728x86\u4e0a\uff0cstruct thread_info\u5728\u6587\u4ef6 \u4e2d\u5b9a\u4e49\uff08./arch/x86/include/asm/thread_info.h\uff09 struct thread_info { struct task_struct * task ; /* main task structure */ bfstruct exec_domain * exec_domain ; /* execution domain */ __u32 flags ; /* low level flags */ __u32 status ; /* thread synchronous flags */ __u32 cpu ; /* current CPU */ int preempt_count ; /* 0 => preemptable, <0 => BUG */ mm_segment_t addr_limit ; struct restart_block restart_block ; void __user * sysenter_return ; #ifdef CONFIG_X86_32 unsigned long previous_esp ; /* ESP of the previous stack in case of nested (IRQ) stacks */ __u8 supervisor_stack [ 0 ]; #endif int uaccess_err ; }; \u5728\u5185\u6838\u4e2d\uff0c\u8bbf\u95ee\u4efb\u52a1\u901a\u5e38\u9700\u8981\u83b7\u5f97\u6307\u5411\u5176task_struct\u7684\u6307\u9488\uff1b \u9488\u5bf9\u4e0d\u540c\u7684\u786c\u4ef6\u4f53\u7cfb\u7ed3\u6784\uff0c\u83b7\u53d6task_struct\u7684\u51fd\u6570\u6216\u5b8f\u6709\u7740\u4e0d\u540c\u7684\u5b9e\u73b0\u65b9\u5f0f\uff1b \u6709\u7684\u786c\u4ef6\u7ed3\u6784\u53ef\u4ee5\u62ff\u51fa\u4e00\u4e2a\u4e13\u95e8\u7684\u5bc4\u5b58\u5668\u6765\u5b58\u653e\u6307\u5411\u5f53\u524d\u8fdb\u7a0btask_struct\u7684\u6307\u9488\uff0c\u7528\u4e8e\u52a0\u5feb\u8bbf\u95ee\u901f\u5ea6\u3002\u6709\u4e9b\u50cfx86\u8fd9\u6837\u7684\u4f53\u7cfb\u7ed3\u6784\uff08\u5176\u5bc4\u5b58\u5668\u5e76\u4e0d\u5bcc\u4f59\uff09\uff0c\u5c31\u53ea\u80fd\u5728\u5185\u6838\u6808\u7684\u5c3e\u7aef\u521b\u5efathread_info\u7ed3\u6784\uff0c\u901a\u8fc7\u8ba1\u7b97\u504f\u79fb\u95f4\u63a5\u5730\u67e5\u627etask_struct\u7ed3\u6784\u3002 \u83b7\u53d6thread_info\u7684\u51fd\u6570\u7684C\u548c\u6c47\u7f16\u7684\u5b9e\u73b0\u65b9\u5f0f\u5982\u4e0b\uff08./arch/x86/include/asm/thread_info.h \uff09 /* how to get the current stack pointer from C */ register unsigned long current_stack_pointer asm ( \"esp\" ) __used ; /* how to get the thread information struct from C */ static inline struct thread_info * current_thread_info ( void ) { return ( struct thread_info * ) ( current_stack_pointer & ~ ( THREAD_SIZE - 1 )); } \u5047\u5b9a\u6808\u7684\u5927\u5c0f\u4e3a8KB\u65f6\uff0c\u53732^13B\uff0c\u901a\u8fc7\u5c4f\u853d\u6808\u6307\u9488\u7684\u540e13\u4e2a\u6709\u6548\u4f4d\uff0c\u6765\u8ba1\u7b97thread_info\u7684\u5730\u5740; esp\u4e3a\u6269\u5c55\u6808\u6307\u9488\u5bc4\u5b58\u5668\uff0c\u662f\u6307\u9488\u5bc4\u5b58\u5668\u7684\u4e00\u79cd\uff0c\u7528\u4e8e\u5b58\u653e\u51fd\u6570\u6808\u9876\u6307\u9488\u3002\u4e0e\u4e4b\u5bf9\u5e94\u7684\u662febp\uff0c\u6269\u5c55\u57fa\u5740\u6307\u9488\u5bc4\u5b58\u5668\uff0c\u4e5f\u88ab\u79f0\u4e3a\u5e27\u6307\u9488\u5bc4\u5b58\u5668\uff0c\u7528\u4e8e\u5b58\u653e\u51fd\u6570\u6808\u5e95\u6307\u9488\uff1b \u56e0\u4e3aesp\u6307\u5411\u7684\u662f\u5f53\u524d\u8fdb\u7a0b\u6808\u7a7a\u95f4\u7684\u67d0\u4e00\u4e2a\u51fd\u6570\u6808\uff0c\u5373\u901a\u8fc7\u5c4f\u853desp\u7684\u540e13\u4e2a\u6709\u6548\u4f4d\u53ef\u4ee5\u83b7\u53d6\u5f53\u524d\u8fdb\u7a0b\u6808\u5c3e\u7aef\u5730\u5740\uff0c\u5373\u53ef\u4ee5\u83b7\u5f97thread_info\u5730\u5740\uff1b \u5728\u5206\u6790\u5185\u6838\u65f6\u6ce8\u610f\u5230\u6709\u4e9b\u51fd\u6570\u4f1a\u6709\u6dfb\u52a0__attribute__((unused))\uff0c \u5728gcc\u624b\u518c\u4e2d\u627e\u5230\u4e86\u6709\u5173\u7684\u89e3\u91ca\uff1a unused\uff1aThis attribute, attached to a function, means that the function is meant to be possibly unused. GCC will not produce a warning for this function. used\uff1a This attribute, attached to a function, means that code must be emitted for the function even if it appears that the function is not referenced. This is useful, for example, when the function is referenced only in inline assembly. \u8868\u793a\u8be5\u51fd\u6570\u6216\u53d8\u91cf\u53ef\u80fd\u4e0d\u4f7f\u7528\uff0c\u8fd9\u4e2a\u5c5e\u6027\u53ef\u4ee5\u907f\u514d\u7f16\u8bd1\u5668\u4ea7\u751f\u8b66\u544a\u4fe1\u606f #else /* !__ASSEMBLY__ */ /* how to get the thread information struct from ASM */ #define GET_THREAD_INFO(reg) \\ movl $-THREAD_SIZE, reg; \\ andl %esp, reg /* use this one if reg already contains %esp */ #define GET_THREAD_INFO_WITH_ESP(reg) \\ andl $-THREAD_SIZE, reg #endif \u4e0egcc\u6709\u5173\u7684\u4fe1\u606f\u53ef\u4ee5\u67e5\u770b ./include/linux/compiler-gcc.h \u6587\u4ef6 \u76f8\u6bd4\u4e0ex86\u7cfb\u7edf\uff0cpowerpc\u7cfb\u7edf\u6709\u8db3\u591f\u591a\u7684\u5bc4\u5b58\u5668\uff0c\u800c\u8bbf\u95ee\u8fdb\u7a0b\u63cf\u8ff0\u7b26\u662f\u4e00\u4e2a\u91cd\u8981\u7684\u9891\u7e41\u64cd\u4f5c\uff0c\u6240\u4ee5ppc\u7684\u5185\u6838\u5f00\u53d1\u8005\u5c06\u5f53\u524d\u7684task_struct\u4fdd\u5b58\u5728\u4e00\u4e2a\u5bc4\u5b58\u5668\u4e2d\u3002","title":"\u8fdb\u7a0b\u63cf\u8ff0\u7b26"},{"location":"%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6/#1","text":"\u5185\u6838\u628a\u8fdb\u7a0b\u7684\u5217\u8868\u5b58\u653e\u5728\u53eb\u505a\u4efb\u52a1\u961f\u5217\uff08task list\uff09\u7684\u53cc\u5411\u5faa\u73af\u94fe\u8868\u4e2d\u3002\u94fe\u8868\u4e2d\u7684\u6bcf\u4e00\u9879\u90fd\u662f\u7c7b\u578b\u4e3a task_struct \u7684\u8fdb\u7a0b\u63cf\u8ff0\u7b26\u7ed3\u6784\uff0c\u8be5\u7ed3\u6784\u5b9a\u4e49\u5728 \u6587\u4ef6\u4e2d\uff08./include/linux/sched.h)\u3002\u8fdb\u7a0b\u63cf\u8ff0\u7b26\u5305\u542b\u4e86\u4e00\u4e2a\u5177\u4f53\u8fdb\u7a0b\u7684\u6240\u6709\u4fe1\u606f\u3002 struct task_struct { volatile long state ; /* -1 unrunnable, 0 runnable, >0 stopped */ void * stack ; atomic_t usage ; unsigned int flags ; /* per process flags, defined below */ unsigned int ptrace ; int lock_depth ; /* BKL lock depth */ #ifdef CONFIG_SMP #ifdef __ARCH_WANT_UNLOCKED_CTXSW int oncpu ; #endif #endif int prio , static_prio , normal_prio ; unsigned int rt_priority ; const struct sched_class * sched_class ; struct sched_entity se ; struct sched_rt_entity rt ; #ifdef CONFIG_PREEMPT_NOTIFIERS /* list of struct preempt_notifier: */ struct hlist_head preempt_notifiers ; #endif /* * fpu_counter contains the number of consecutive context switches * that the FPU is used. If this is over a threshold, the lazy fpu * saving becomes unlazy to save the trap. This is an unsigned char * so that after 256 times the counter wraps and the behavior turns * lazy again; this to deal with bursty apps that only use FPU for * a short time */ unsigned char fpu_counter ; #ifdef CONFIG_BLK_DEV_IO_TRACE unsigned int btrace_seq ; #endif unsigned int policy ; cpumask_t cpus_allowed ; #ifdef CONFIG_TREE_PREEMPT_RCU int rcu_read_lock_nesting ; char rcu_read_unlock_special ; struct rcu_node * rcu_blocked_node ; struct list_head rcu_node_entry ; #endif /* #ifdef CONFIG_TREE_PREEMPT_RCU */ #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) struct sched_info sched_info ; #endif struct list_head tasks ; struct plist_node pushable_tasks ; struct mm_struct * mm , * active_mm ; #if defined(SPLIT_RSS_COUNTING) struct task_rss_stat rss_stat ; #endif /* task state */ int exit_state ; int exit_code , exit_signal ; int pdeath_signal ; /* The signal sent when the parent dies */ /* ??? */ unsigned int personality ; unsigned did_exec : 1 ; unsigned in_execve : 1 ; /* Tell the LSMs that the process is doing an * execve */ unsigned in_iowait : 1 ; /* Revert to default priority/policy when forking */ unsigned sched_reset_on_fork : 1 ; pid_t pid ; pid_t tgid ; #ifdef CONFIG_CC_STACKPROTECTOR /* Canary value for the -fstack-protector gcc feature */ unsigned long stack_canary ; #endif /* * pointers to (original) parent process, youngest child, younger sibling, * older sibling, respectively. (p->father can be replaced with * p->real_parent->pid) */ struct task_struct * real_parent ; /* real parent process */ struct task_struct * parent ; /* recipient of SIGCHLD, wait4() reports */ /* * children/sibling forms the list of my natural children */ struct list_head children ; /* list of my children */ struct list_head sibling ; /* linkage in my parent's children list */ struct task_struct * group_leader ; /* threadgroup leader */ /* * ptraced is the list of tasks this task is using ptrace on. * This includes both natural children and PTRACE_ATTACH targets. * p->ptrace_entry is p's link on the p->parent->ptraced list. */ struct list_head ptraced ; struct list_head ptrace_entry ; /* * This is the tracer handle for the ptrace BTS extension. * This field actually belongs to the ptracer task. */ struct bts_context * bts ; /* PID/PID hash table linkage. */ struct pid_link pids [ PIDTYPE_MAX ]; struct list_head thread_group ; struct completion * vfork_done ; /* for vfork() */ int __user * set_child_tid ; /* CLONE_CHILD_SETTID */ int __user * clear_child_tid ; /* CLONE_CHILD_CLEARTID */ cputime_t utime , stime , utimescaled , stimescaled ; cputime_t gtime ; #ifndef CONFIG_VIRT_CPU_ACCOUNTING cputime_t prev_utime , prev_stime ; #endif unsigned long nvcsw , nivcsw ; /* context switch counts */ struct timespec start_time ; /* monotonic time */ struct timespec real_start_time ; /* boot based time */ /* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */ unsigned long min_flt , maj_flt ; struct task_cputime cputime_expires ; struct list_head cpu_timers [ 3 ]; /* process credentials */ const struct cred * real_cred ; /* objective and real subjective task * credentials (COW) */ const struct cred * cred ; /* effective (overridable) subjective task * credentials (COW) */ struct mutex cred_guard_mutex ; /* guard against foreign influences on * credential calculations * (notably. ptrace) */ struct cred * replacement_session_keyring ; /* for KEYCTL_SESSION_TO_PARENT */ char comm [ TASK_COMM_LEN ]; /* executable name excluding path - access with [gs]et_task_comm (which lock it with task_lock()) - initialized normally by setup_new_exec */ /* file system info */ int link_count , total_link_count ; #ifdef CONFIG_SYSVIPC /* ipc stuff */ struct sysv_sem sysvsem ; #endif #ifdef CONFIG_DETECT_HUNG_TASK /* hung task detection */ unsigned long last_switch_count ; #endif /* CPU-specific state of this task */ struct thread_struct thread ; /* filesystem information */ struct fs_struct * fs ; /* open file information */ struct files_struct * files ; /* namespaces */ struct nsproxy * nsproxy ; /* signal handlers */ struct signal_struct * signal ; struct sighand_struct * sighand ; sigset_t blocked , real_blocked ; sigset_t saved_sigmask ; /* restored if set_restore_sigmask() was used */ struct sigpending pending ; unsigned long sas_ss_sp ; size_t sas_ss_size ; int ( * notifier )( void * priv ); void * notifier_data ; sigset_t * notifier_mask ; struct audit_context * audit_context ; #ifdef CONFIG_AUDITSYSCALL uid_t loginuid ; unsigned int sessionid ; #endif seccomp_t seccomp ; /* Thread group tracking */ u32 parent_exec_id ; u32 self_exec_id ; /* Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed, * mempolicy */ spinlock_t alloc_lock ; #ifdef CONFIG_GENERIC_HARDIRQS /* IRQ handler threads */ struct irqaction * irqaction ; #endif /* Protection of the PI data structures: */ raw_spinlock_t pi_lock ; #ifdef CONFIG_RT_MUTEXES /* PI waiters blocked on a rt_mutex held by this task */ struct plist_head pi_waiters ; /* Deadlock detection and priority inheritance handling */ struct rt_mutex_waiter * pi_blocked_on ; #endif #ifdef CONFIG_DEBUG_MUTEXES /* mutex deadlock detection */ struct mutex_waiter * blocked_on ; #endif #ifdef CONFIG_TRACE_IRQFLAGS unsigned int irq_events ; unsigned long hardirq_enable_ip ; unsigned long hardirq_disable_ip ; unsigned int hardirq_enable_event ; unsigned int hardirq_disable_event ; int hardirqs_enabled ; int hardirq_context ; unsigned long softirq_disable_ip ; unsigned long softirq_enable_ip ; unsigned int softirq_disable_event ; unsigned int softirq_enable_event ; int softirqs_enabled ; int softirq_context ; #endif #ifdef CONFIG_LOCKDEP # define MAX_LOCK_DEPTH 48UL u64 curr_chain_key ; int lockdep_depth ; unsigned int lockdep_recursion ; struct held_lock held_locks [ MAX_LOCK_DEPTH ]; gfp_t lockdep_reclaim_gfp ; #endif /* journalling filesystem info */ void * journal_info ; /* stacked block device info */ struct bio_list * bio_list ; /* VM state */ struct reclaim_state * reclaim_state ; struct backing_dev_info * backing_dev_info ; struct io_context * io_context ; unsigned long ptrace_message ; siginfo_t * last_siginfo ; /* For ptrace use. */ struct task_io_accounting ioac ; #if defined(CONFIG_TASK_XACCT) u64 acct_rss_mem1 ; /* accumulated rss usage */ u64 acct_vm_mem1 ; /* accumulated virtual memory usage */ cputime_t acct_timexpd ; /* stime + utime since last update */ #endif #ifdef CONFIG_CPUSETS nodemask_t mems_allowed ; /* Protected by alloc_lock */ int cpuset_mem_spread_rotor ; #endif #ifdef CONFIG_CGROUPS /* Control Group info protected by css_set_lock */ struct css_set * cgroups ; /* cg_list protected by css_set_lock and tsk->alloc_lock */ struct list_head cg_list ; #endif #ifdef CONFIG_FUTEX struct robust_list_head __user * robust_list ; #ifdef CONFIG_COMPAT struct compat_robust_list_head __user * compat_robust_list ; #endif struct list_head pi_state_list ; struct futex_pi_state * pi_state_cache ; #endif #ifdef CONFIG_PERF_EVENTS struct perf_event_context * perf_event_ctxp ; struct mutex perf_event_mutex ; struct list_head perf_event_list ; #endif #ifdef CONFIG_NUMA struct mempolicy * mempolicy ; /* Protected by alloc_lock */ short il_next ; #endif atomic_t fs_excl ; /* holding fs exclusive resources */ struct rcu_head rcu ; /* * cache last used pipe for splice */ struct pipe_inode_info * splice_pipe ; #ifdef CONFIG_TASK_DELAY_ACCT struct task_delay_info * delays ; #endif #ifdef CONFIG_FAULT_INJECTION int make_it_fail ; #endif struct prop_local_single dirties ; #ifdef CONFIG_LATENCYTOP int latency_record_count ; struct latency_record latency_record [ LT_SAVECOUNT ]; #endif /* * time slack values; these are used to round up poll() and * select() etc timeout values. These are in nanoseconds. */ unsigned long timer_slack_ns ; unsigned long default_timer_slack_ns ; struct list_head * scm_work_list ; #ifdef CONFIG_FUNCTION_GRAPH_TRACER /* Index of current stored address in ret_stack */ int curr_ret_stack ; /* Stack of return addresses for return function tracing */ struct ftrace_ret_stack * ret_stack ; /* time stamp for last schedule */ unsigned long long ftrace_timestamp ; /* * Number of functions that haven't been traced * because of depth overrun. */ atomic_t trace_overrun ; /* Pause for the tracing */ atomic_t tracing_graph_pause ; #endif #ifdef CONFIG_TRACING /* state flags for use by tracers */ unsigned long trace ; /* bitmask of trace recursion */ unsigned long trace_recursion ; #endif /* CONFIG_TRACING */ #ifdef CONFIG_CGROUP_MEM_RES_CTLR /* memcg uses this to do batch job */ struct memcg_batch_info { int do_batch ; /* incremented when batch uncharge started */ struct mem_cgroup * memcg ; /* target memcg of uncharge */ unsigned long bytes ; /* uncharged usage */ unsigned long memsw_bytes ; /* uncharged mem+swap usage */ } memcg_batch ; #endif };","title":"1 \u8fdb\u7a0b\u63cf\u8ff0\u7b26\u7684\u7ed3\u6784"},{"location":"%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6/#2","text":"Linux\u901a\u8fc7slab\u5206\u914d\u5668\u5206\u914dtask_struct\u7ed3\u6784\uff0c\u8fd9\u6837\u80fd\u8fbe\u5230\u5bf9\u8c61\u590d\u7528\u548c\u7f13\u5b58\u7740\u8272\u5668\uff08cache \u3001coloring\uff09\u7684\u76ee\u7684\u3002\u57282.6\u4ee5\u524d\u7684\u5185\u6838\u4e2d\uff0c\u5404\u4e2a\u8fdb\u7a0b\u7684task_struct\u5b58\u653e\u5728\u5b83\u4eec\u5185\u6838\u6808\u7684\u5c3e\u7aef\u3002\u8fd9\u6837\u505a\u662f\u4e3a\u4e86\u8ba9\u90a3\u4e9b\u50cfx86\u90a3\u6837\u5bc4\u5b58\u5668\u8f83\u5c11\u7684\u786c\u4ef6\u4f53\u7cfb\u7ed3\u6784\u53ea\u8981\u901a\u8fc7\u6808\u6307\u9488\u5c31\u80fd\u8ba1\u7b97\u51fa\u5b83\u7684\u4f4d\u7f6e\uff0c\u800c\u907f\u514d\u4f7f\u7528\u989d\u5916\u7684\u5bc4\u5b58\u5668\u4e13\u95e8\u8bb0\u5f55\u3002\u7531\u4e8e\u73b0\u5728\u7528slab\u5206\u914d\u5668\u52a8\u6001\u751f\u6210task_struct\uff0c\u6240\u4ee5\u53ea\u9700\u5728\u6808\u5e95\uff08\u5bf9\u4e8e\u5411\u4e0b\u589e\u957f\u7684\u6808\u6765\u8bf4\uff09\u6216\u6808\u9876\uff08\u5bf9\u4e8e\u5411\u4e0a\u589e\u957f\u7684\u6808\u6765\u8bf4\uff09\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7ed3\u6784struct thread_info \u3002 \u6bcf\u4e2a\u4efb\u52a1\u7684thread_info\u7ed3\u6784\u5728\u5b83\u7684\u5185\u6838\u7684\u5c3e\u7aef\u5206\u914d\u3002\u7ed3\u6784\u4e2dtask\u57df\u4e2d\u5b58\u653e\u7684\u662f\u6307\u5411\u8be5\u4efb\u52a1\u5b9e\u9645task_struct\u7684\u6307\u9488\u3002 \u5728x86\u4e0a\uff0cstruct thread_info\u5728\u6587\u4ef6 \u4e2d\u5b9a\u4e49\uff08./arch/x86/include/asm/thread_info.h\uff09 struct thread_info { struct task_struct * task ; /* main task structure */ bfstruct exec_domain * exec_domain ; /* execution domain */ __u32 flags ; /* low level flags */ __u32 status ; /* thread synchronous flags */ __u32 cpu ; /* current CPU */ int preempt_count ; /* 0 => preemptable, <0 => BUG */ mm_segment_t addr_limit ; struct restart_block restart_block ; void __user * sysenter_return ; #ifdef CONFIG_X86_32 unsigned long previous_esp ; /* ESP of the previous stack in case of nested (IRQ) stacks */ __u8 supervisor_stack [ 0 ]; #endif int uaccess_err ; }; \u5728\u5185\u6838\u4e2d\uff0c\u8bbf\u95ee\u4efb\u52a1\u901a\u5e38\u9700\u8981\u83b7\u5f97\u6307\u5411\u5176task_struct\u7684\u6307\u9488\uff1b \u9488\u5bf9\u4e0d\u540c\u7684\u786c\u4ef6\u4f53\u7cfb\u7ed3\u6784\uff0c\u83b7\u53d6task_struct\u7684\u51fd\u6570\u6216\u5b8f\u6709\u7740\u4e0d\u540c\u7684\u5b9e\u73b0\u65b9\u5f0f\uff1b \u6709\u7684\u786c\u4ef6\u7ed3\u6784\u53ef\u4ee5\u62ff\u51fa\u4e00\u4e2a\u4e13\u95e8\u7684\u5bc4\u5b58\u5668\u6765\u5b58\u653e\u6307\u5411\u5f53\u524d\u8fdb\u7a0btask_struct\u7684\u6307\u9488\uff0c\u7528\u4e8e\u52a0\u5feb\u8bbf\u95ee\u901f\u5ea6\u3002\u6709\u4e9b\u50cfx86\u8fd9\u6837\u7684\u4f53\u7cfb\u7ed3\u6784\uff08\u5176\u5bc4\u5b58\u5668\u5e76\u4e0d\u5bcc\u4f59\uff09\uff0c\u5c31\u53ea\u80fd\u5728\u5185\u6838\u6808\u7684\u5c3e\u7aef\u521b\u5efathread_info\u7ed3\u6784\uff0c\u901a\u8fc7\u8ba1\u7b97\u504f\u79fb\u95f4\u63a5\u5730\u67e5\u627etask_struct\u7ed3\u6784\u3002 \u83b7\u53d6thread_info\u7684\u51fd\u6570\u7684C\u548c\u6c47\u7f16\u7684\u5b9e\u73b0\u65b9\u5f0f\u5982\u4e0b\uff08./arch/x86/include/asm/thread_info.h \uff09 /* how to get the current stack pointer from C */ register unsigned long current_stack_pointer asm ( \"esp\" ) __used ; /* how to get the thread information struct from C */ static inline struct thread_info * current_thread_info ( void ) { return ( struct thread_info * ) ( current_stack_pointer & ~ ( THREAD_SIZE - 1 )); } \u5047\u5b9a\u6808\u7684\u5927\u5c0f\u4e3a8KB\u65f6\uff0c\u53732^13B\uff0c\u901a\u8fc7\u5c4f\u853d\u6808\u6307\u9488\u7684\u540e13\u4e2a\u6709\u6548\u4f4d\uff0c\u6765\u8ba1\u7b97thread_info\u7684\u5730\u5740; esp\u4e3a\u6269\u5c55\u6808\u6307\u9488\u5bc4\u5b58\u5668\uff0c\u662f\u6307\u9488\u5bc4\u5b58\u5668\u7684\u4e00\u79cd\uff0c\u7528\u4e8e\u5b58\u653e\u51fd\u6570\u6808\u9876\u6307\u9488\u3002\u4e0e\u4e4b\u5bf9\u5e94\u7684\u662febp\uff0c\u6269\u5c55\u57fa\u5740\u6307\u9488\u5bc4\u5b58\u5668\uff0c\u4e5f\u88ab\u79f0\u4e3a\u5e27\u6307\u9488\u5bc4\u5b58\u5668\uff0c\u7528\u4e8e\u5b58\u653e\u51fd\u6570\u6808\u5e95\u6307\u9488\uff1b \u56e0\u4e3aesp\u6307\u5411\u7684\u662f\u5f53\u524d\u8fdb\u7a0b\u6808\u7a7a\u95f4\u7684\u67d0\u4e00\u4e2a\u51fd\u6570\u6808\uff0c\u5373\u901a\u8fc7\u5c4f\u853desp\u7684\u540e13\u4e2a\u6709\u6548\u4f4d\u53ef\u4ee5\u83b7\u53d6\u5f53\u524d\u8fdb\u7a0b\u6808\u5c3e\u7aef\u5730\u5740\uff0c\u5373\u53ef\u4ee5\u83b7\u5f97thread_info\u5730\u5740\uff1b \u5728\u5206\u6790\u5185\u6838\u65f6\u6ce8\u610f\u5230\u6709\u4e9b\u51fd\u6570\u4f1a\u6709\u6dfb\u52a0__attribute__((unused))\uff0c \u5728gcc\u624b\u518c\u4e2d\u627e\u5230\u4e86\u6709\u5173\u7684\u89e3\u91ca\uff1a unused\uff1aThis attribute, attached to a function, means that the function is meant to be possibly unused. GCC will not produce a warning for this function. used\uff1a This attribute, attached to a function, means that code must be emitted for the function even if it appears that the function is not referenced. This is useful, for example, when the function is referenced only in inline assembly. \u8868\u793a\u8be5\u51fd\u6570\u6216\u53d8\u91cf\u53ef\u80fd\u4e0d\u4f7f\u7528\uff0c\u8fd9\u4e2a\u5c5e\u6027\u53ef\u4ee5\u907f\u514d\u7f16\u8bd1\u5668\u4ea7\u751f\u8b66\u544a\u4fe1\u606f #else /* !__ASSEMBLY__ */ /* how to get the thread information struct from ASM */ #define GET_THREAD_INFO(reg) \\ movl $-THREAD_SIZE, reg; \\ andl %esp, reg /* use this one if reg already contains %esp */ #define GET_THREAD_INFO_WITH_ESP(reg) \\ andl $-THREAD_SIZE, reg #endif \u4e0egcc\u6709\u5173\u7684\u4fe1\u606f\u53ef\u4ee5\u67e5\u770b ./include/linux/compiler-gcc.h \u6587\u4ef6 \u76f8\u6bd4\u4e0ex86\u7cfb\u7edf\uff0cpowerpc\u7cfb\u7edf\u6709\u8db3\u591f\u591a\u7684\u5bc4\u5b58\u5668\uff0c\u800c\u8bbf\u95ee\u8fdb\u7a0b\u63cf\u8ff0\u7b26\u662f\u4e00\u4e2a\u91cd\u8981\u7684\u9891\u7e41\u64cd\u4f5c\uff0c\u6240\u4ee5ppc\u7684\u5185\u6838\u5f00\u53d1\u8005\u5c06\u5f53\u524d\u7684task_struct\u4fdd\u5b58\u5728\u4e00\u4e2a\u5bc4\u5b58\u5668\u4e2d\u3002","title":"2 \u8fdb\u7a0b\u63cf\u8ff0\u7b26\u7684\u5b58\u653e"},{"location":"%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/","text":"volatile long state ; /* -1 unrunnable, 0 runnable, >0 stopped */ ... /* task state */ int exit_state ; int exit_code , exit_signal ; int pdeath_signal ; /* The signal sent when the parent dies */ /* ??? */ unsigned int personality ; unsigned did_exec : 1 ; unsigned in_execve : 1 ; /* Tell the LSMs that the process is doing an * execve */ unsigned in_iowait : 1 ; /* Revert to default priority/policy when forking */ unsigned sched_reset_on_fork : 1 ; \u5f53\u8981\u6c42\u4f7f\u7528 volatile \u58f0\u660e\u7684\u53d8\u91cf\u7684\u503c\u7684\u65f6\u5019\uff0c\u7cfb\u7edf\u603b\u662f\u91cd\u65b0\u4ece\u5b83\u6240\u5728\u7684\u5185\u5b58\u8bfb\u53d6\u6570\u636e\uff0c\u5373\u4f7f\u5b83\u524d\u9762\u7684\u6307\u4ee4\u521a\u521a\u4ece\u8be5\u5904\u8bfb\u53d6\u8fc7\u6570\u636e\u3002\u800c\u4e14\u8bfb\u53d6\u7684\u6570\u636e\u7acb\u523b\u88ab\u4fdd\u5b58\u3002 \u901a\u8fc7set_task_state(task, state)\u8bbe\u7f6e\u8fdb\u7a0b\u7684\u72b6\u6001; \u4ee3\u7801\u4f4d\u7f6e ./include/linux/sched.h #define __set_task_state(tsk, state_value) \\ do { (tsk)->state = (state_value); } while (0) #define set_task_state(tsk, state_value) \\ set_mb((tsk)->state, (state_value)) ps:\u5176\u4e2ddo{}while(0)\u8bed\u53e5\u662f\u4e3a\u4e86\u9632\u6b62\u5b8f\u5931\u6548 \u4f8b\u5982\uff1a #define Hong(p) A(p); B(p); if(p!=NULL) Hong(p) else ... #\u5b8f\u5c55\u5f00\u540eelse\u5931\u6548 if(p!=NULL) A(p); B(p); else ... #define Hong(p) {A(p); B(p);} if(p!=NULL) Hong(p); else ... #\u5b8f\u5c55\u5f00\u540eelse\u5931\u6548 if(p!=NULL) { A(p); B(p); }; else ... \u5f88\u660e\u663e\uff0ccurrent\u6307\u5411\u7684\u662f\u5f53\u524d\u8fdb\u7a0b\u7684\u8fdb\u7a0b\u63cf\u8ff0\u7b26 #define __set_current_state(state_value) \\ do { current->state = (state_value); } while (0) #define set_current_state(state_value) \\ set_mb(current->state, (state_value)) \u5f53\u4e00\u4e2a\u7a0b\u5e8f\u8c03\u7528\u6267\u884c\u4e86\u7cfb\u7edf\u8c03\u7528\u6216\u8005\u89e6\u53d1\u4e86\u67d0\u4e2a\u5f02\u5e38\uff0c\u5b83\u5c31\u9677\u5165\u4e86\u5185\u6838\u7a7a\u95f4\u3002\u6b64\u65f6\uff0c\u6211\u4eec\u79f0\u5185\u6838\u201c\u4ee3\u8868\u8fdb\u7a0b\u6267\u884c\u201d\u5e76\u5904\u4e8e\u8fdb\u7a0b\u4e0a\u4e0b\u6587\u4e2d\u3002\u5728\u6b64\u4e0a\u4e0b\u6587\u4e2dcurrent\u5b8f\u662f\u6709\u6548\u7684\uff08current\u6307\u5411\u5f53\u524d\u8fdb\u7a0b\u7684\u8fdb\u7a0b\u63cf\u8ff0\u7b26\uff09\u3002\u9664\u975e\u5728\u6b64\u95f4\u9699\u6709\u66f4\u9ad8\u4f18\u5148\u7ea7\u7684\u8fdb\u7a0b\u9700\u8981\u6267\u884c\u5e76\u7531\u8c03\u5ea6\u5668\u505a\u51fa\u4e86\u76f8\u5e94\u8c03\u6574\uff0c\u5426\u5219\u5728\u5185\u6838\u63a8\u51fa\u7684\u65f6\u5019\uff0c\u7a0b\u5e8f\u6062\u590d\u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u7ee7\u7eed\u6267\u884c\u3002","title":"\u8fdb\u7a0b\u72b6\u6001"},{"location":"%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","text":"Linux\u5b9e\u73b0\u4e2d\uff0c\u7ebf\u7a0b\u548c\u8fdb\u7a0b\u4e0d\u4f1a\u7279\u522b\u533a\u5206 \u73b0\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u5b58\u5728\u865a\u62df\u5185\u5b58\u548c\u865a\u62df\u5904\u7406\u5668\u4e24\u79cd\u865a\u62df\u673a\u5236\uff1b\u540c\u8fdb\u7a0b\u4e0b\u7ebf\u7a0b\u5171\u4eab\u865a\u62df\u5185\u5b58\uff0c\u4e0d\u540c\u7ebf\u7a0b\u5206\u522b\u62e5\u6709\u81ea\u5df1\u7684\u865a\u62df\u5904\u7406\u5668 \u7a0b\u5e8f\u672c\u8eab\u4e0d\u662f\u8fdb\u7a0b\uff0c\u8fdb\u7a0b\u662f\u5904\u4e8e\u6267\u884c\u671f\u7684\u7a0b\u5e8f\u53ca\u76f8\u5173\u8d44\u6e90\u7684\u603b\u79f0\u3002 Linux\u4e2d\u901a\u8fc7\u8c03\u7528fork\u51fd\u6570\u521b\u5efa\u8fdb\u7a0b\u3002\u8c03\u7528fork\u51fd\u6570\u7684\u8fdb\u7a0b\u88ab\u79f0\u4e3a\u7236\u8fdb\u7a0b\uff0c\u4ea7\u751f\u7684\u8fdb\u7a0b\u88ab\u79f0\u4e3a\u5b50\u8fdb\u7a0b\uff1b\u5728\u8be5\u51fd\u6570\u8c03\u7528\u7ed3\u675f\u65f6\uff0c\u5728\u8fd4\u56de\u70b9\u4e0a\uff0c\u7236\u8fdb\u7a0b\u6062\u590d\u6267\u884c\uff0c\u5b50\u8fdb\u7a0b\u5f00\u59cb\u6267\u884c\uff1bfork\u7cfb\u7edf\u8c03\u7528\u4ece\u5185\u6838\u8fd4\u56de\u4e24\u6b21\uff1a\u4e00\u6b21\u56de\u5230\u7236\u8fdb\u7a0b\uff0c\u53e6\u4e00\u6b21\u56de\u5230\u65b0\u4ea7\u751f\u7684\u5b50\u8fdb\u7a0b\uff1b \u63a5\u7740\u901a\u8fc7\u8c03\u7528exec\u51fd\u6570\u521b\u5efa\u65b0\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u5e76\u8f7d\u5165\u65b0\u7684\u7a0b\u5e8f\uff1b\u5728\u73b0\u4ee3Linux\u5185\u6838\u4e2d\uff0cfork\u5b9e\u9645\u4e0a\u6709clone\u51fd\u6570\u5b9e\u73b0\u7684\uff1b \u6700\u7ec8\uff0c\u7a0b\u5e8f\u901a\u8fc7exit\u51fd\u6570\u8c03\u7528\u9000\u51fa\u6267\u884c\uff0c\u8fd9\u51fd\u6570\u5c06\u7ec8\u7ed3\u8fdb\u7a0b\u5e76\u5c06\u5360\u7528\u7684\u8d44\u6e90\u91ca\u653e\u6389\uff1b\u7236\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7wait4\u7cfb\u7edf\u8c03\u7528\u67e5\u8be2\u8fdb\u7a0b\u662f\u5426\u7ec8\u7ed3\uff08\u7531\u5185\u6838\u8d1f\u8d23\u5b9e\u73b0wait4\u7cfb\u7edf\u8c03\u7528\uff0cLinux\u7cfb\u7edf\u901a\u8fc7C\u5e93\u901a\u5e38\u8981\u63d0\u4f9bwait\u3001waitpid\u3001wait3\u3001wait4\u51fd\u6570\uff09\uff1b\u8fdb\u7a0b\u9000\u51fa\u6267\u884c\u540e\u88ab\u8bbe\u7f6e\u4e3a\u50f5\u6b7b\u72b6\u6001\uff0c\u76f4\u5230\u5b83\u7684\u7236\u8fdb\u7a0b\u8c03\u7528wait\u6216waitpid\u4e3a\u6b62\u3002","title":"\u8fdb\u7a0b\u751f\u547d\u5468\u671f"},{"location":"%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2/","text":"\u4e00\u822c\u6765\u8bf4\uff0c\u8fdb\u7a0b\u7684\u6790\u6784\u662f\u81ea\u8eab\u5f15\u8d77\u7684\uff0c\u5b83\u53d1\u751f\u5728\u8fdb\u7a0b\u8c03\u7528exit()\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u65e2\u53ef\u4ee5\u663e\u793a\u5730\u8c03\u7528\u8fd9\u4e2a\u7cfb\u7edf\u8c03\u7528\uff0c\u4e5f\u53ef\u4ee5\u9690\u5f0f\u5730\u4ece\u67d0\u4e2a\u7a0b\u5e8f\u7684\u4e3b\u51fd\u6570\u8fd4\u56de\uff08\u5176\u5b9eC\u8bed\u8a00\u7f16\u8bd1\u5668\u4f1a\u5728main\u51fd\u6570\u8fd4\u56de\u70b9\u540e\u653e\u7f6e\u8c03\u7528exit\u7684\u4ee3\u7801\uff09\u3002\u8be5\u4efb\u52a1\u5927\u90e8\u5206\u90fd\u8981\u9760do_exit\u51fd\u6570\u6765\u5b8c\u6210 [./kernel/exit.c]","title":"\u8fdb\u7a0b\u7ec8\u6b62"}]}